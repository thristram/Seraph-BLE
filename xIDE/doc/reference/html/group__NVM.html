<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CSR µEnergy&reg; Firmware: Non-Volatile Memory</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Non-Volatile Memory</h1>  </div>
</div>
<div class="contents">

<p>The NVM library functions provide access to a reserved block (the "NVM Store") within the CSR1000 boot device, to allow the application to read and write configuration settings, security information, etc. at runtime.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9a62f645b18b443e1a3fc3e819c0bc3d"></a><!-- doxytag: member="NVM::NVM_MINIMUM_SIZE" ref="ga9a62f645b18b443e1a3fc3e819c0bc3d" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NVM.html#ga9a62f645b18b443e1a3fc3e819c0bc3d">NVM_MINIMUM_SIZE</a>&#160;&#160;&#160;32</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum size allowed for the NVM Store, in words. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NVM.html#ga2b5779794a2c47bac0321a9fa055cca3">NVM_DEFAULT_ERASED_WORD</a>&#160;&#160;&#160;0xFFFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The default value of an erased location within the NVM Store.  <a href="#ga2b5779794a2c47bac0321a9fa055cca3"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NVM.html#ga9ca3bbabf5a1d7ced0569c85206a7a84">large_spi_flash_erase_size</a> { <a class="el" href="group__NVM.html#gga9ca3bbabf5a1d7ced0569c85206a7a84a38a5fe64314e2c56bab5b0e350a2cc0e">large_spi_erase_4KB</a>, 
<a class="el" href="group__NVM.html#gga9ca3bbabf5a1d7ced0569c85206a7a84ab11bec278483bb1167914ae9f77dbdcf">large_spi_erase_32KB</a>, 
<a class="el" href="group__NVM.html#gga9ca3bbabf5a1d7ced0569c85206a7a84ad41e7d86ea05cbafceb98abf43175f5e">large_spi_erase_256B</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Range of block sizes that may be erased. Not all sizes are supported on all devices: AT25DF011: Supports all sizes MX25L4006E: large_spi_erase_4KB supported large_spi_erase_32KB erases 64KB blocks large_spi_erase_256B not supported. </p>
 <a href="group__NVM.html#ga9ca3bbabf5a1d7ced0569c85206a7a84">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NVM.html#ga573c3a61a76eda3ad848ce6f12e8cab6">NvmConfigureI2cEeprom</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the NVM manager to use an I2C EEPROM for the NVM Store.  <a href="#ga573c3a61a76eda3ad848ce6f12e8cab6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NVM.html#ga32d1e4e408e0e0d3f03f0c0a75cb0b80">NvmConfigureSpiFlash</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the NVM manager to use a SPI Flash for the NVM Store.  <a href="#ga32d1e4e408e0e0d3f03f0c0a75cb0b80"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NVM.html#gaebdda2717982f285aecda5e6b89cc4f2">NvmDisable</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the NVM manager and power off the underlying storage device.  <a href="#gaebdda2717982f285aecda5e6b89cc4f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NVM.html#gaf3d7ab81fb92f6625c10626d3431cc52">NvmRead</a> (uint16 *buffer, uint16 length, uint16 offset)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read words from the NVM Store.  <a href="#gaf3d7ab81fb92f6625c10626d3431cc52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NVM.html#ga9ac04e07dddce56b64b313e76a98055d">NvmWrite</a> (const uint16 *buffer, uint16 length, uint16 offset)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write words to the NVM Store.  <a href="#ga9ac04e07dddce56b64b313e76a98055d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NVM.html#ga5678c24acc660b9bd2545137b2bb31bc">NvmSize</a> (uint16 *size_of_storage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size in words of the NVM Store.  <a href="#ga5678c24acc660b9bd2545137b2bb31bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NVM.html#ga9078121290be3dee311f1ee7f33f671f">NvmErase</a> (bool erase_all)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the contents of the NVM Store.  <a href="#ga9078121290be3dee311f1ee7f33f671f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NVM.html#gab7d5bb787f030e8d6af85b4fd1539d7d">NvmSetI2cEepromDeviceAddress</a> (uint16 address)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the EEPROM device address during I2C operation.  <a href="#gab7d5bb787f030e8d6af85b4fd1539d7d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NVM.html#gadb904fd372444c248c190d255d0f9242">LargeSpiFlashInit</a> (uint16 mosi, uint16 miso, uint16 clk, uint16 ncs, uint16 pow)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the Large SPI Flash library.  <a href="#gadb904fd372444c248c190d255d0f9242"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NVM.html#ga87b0de6c91a309214687632586478feb">LargeSpiFlashEnable</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the PIOs for the Large SPI Flash library. Assumes memory is already powered up and NVM controller is not busy. Disable the NVM controller and set PIOs.  <a href="#ga87b0de6c91a309214687632586478feb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NVM.html#ga842ea04596ed9e9bfd7c2e756ca6de92">LargeSpiFlashDisable</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the Large SPI Flash library. Assumes the NVM controller is already initialised. Enables the NVM controller and restore PIOs.  <a href="#ga842ea04596ed9e9bfd7c2e756ca6de92"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NVM.html#gae6fa5ce3fded4a53b24f90d7ec984853">LargeSpiFlashRead</a> (uint32 address, uint16 length, uint16 *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the Large SPI Flash device.  <a href="#gae6fa5ce3fded4a53b24f90d7ec984853"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NVM.html#ga1ffd46e433a7ed5953bfb33f7743ca55">LargeSpiFlashWrite</a> (uint32 address, uint16 length, const uint16 *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to the Large SPI Flash device.  <a href="#ga1ffd46e433a7ed5953bfb33f7743ca55"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NVM.html#ga6bed9c126f0819fe4f921093e2accbbc">LargeSpiFlashEraseBlock</a> (<a class="el" href="group__NVM.html#ga9ca3bbabf5a1d7ced0569c85206a7a84">large_spi_flash_erase_size</a> size, uint32 address, bool wait)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a single block of the Large SPI Flash device.  <a href="#ga6bed9c126f0819fe4f921093e2accbbc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__NVM.html#ga0524d095f943a7dd0d9c2a1e9b52d666">LargeSpiFlashEraseWaitComplete</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for an erase operation to complete.  <a href="#ga0524d095f943a7dd0d9c2a1e9b52d666"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The NVM library functions provide access to a reserved block (the "NVM Store") within the CSR1000 boot device, to allow the application to read and write configuration settings, security information, etc. at runtime. </p>
<p>The NVM Store contents are retained across power cycles. The library can access either an I2C EEPROM or a SPI Flash device - any device that the CSR1000 can boot from is supported.</p>
<p>The I2C manager does not include any write protection on the NVM Store (i.e. an application write cannot be considered an "atomic" operation) therefore the application should be aware that loss of power during a write cycle may result in corruption of the contents of the NVM Store (e.g. due to having only partially-written the new data).</p>
<p>The SPI NVM Manager uses multiple write regions and additional control information to offer better protection of the integrity of the NVM Store during updates. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga2b5779794a2c47bac0321a9fa055cca3"></a><!-- doxytag: member="nvm.h::NVM_DEFAULT_ERASED_WORD" ref="ga2b5779794a2c47bac0321a9fa055cca3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NVM_DEFAULT_ERASED_WORD&#160;&#160;&#160;0xFFFF</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The default value of an erased location within the NVM Store. </p>
<p>This value may be device-dependent. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga9ca3bbabf5a1d7ced0569c85206a7a84"></a><!-- doxytag: member="large_flash.h::large_spi_flash_erase_size" ref="ga9ca3bbabf5a1d7ced0569c85206a7a84" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__NVM.html#ga9ca3bbabf5a1d7ced0569c85206a7a84">large_spi_flash_erase_size</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Range of block sizes that may be erased. Not all sizes are supported on all devices: AT25DF011: Supports all sizes MX25L4006E: large_spi_erase_4KB supported large_spi_erase_32KB erases 64KB blocks large_spi_erase_256B not supported. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga9ca3bbabf5a1d7ced0569c85206a7a84a38a5fe64314e2c56bab5b0e350a2cc0e"></a><!-- doxytag: member="large_spi_erase_4KB" ref="gga9ca3bbabf5a1d7ced0569c85206a7a84a38a5fe64314e2c56bab5b0e350a2cc0e" args="" -->large_spi_erase_4KB</em>&nbsp;</td><td>
<p>4KB block </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga9ca3bbabf5a1d7ced0569c85206a7a84ab11bec278483bb1167914ae9f77dbdcf"></a><!-- doxytag: member="large_spi_erase_32KB" ref="gga9ca3bbabf5a1d7ced0569c85206a7a84ab11bec278483bb1167914ae9f77dbdcf" args="" -->large_spi_erase_32KB</em>&nbsp;</td><td>
<p>32KB block (64KB on MX25L4006E) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga9ca3bbabf5a1d7ced0569c85206a7a84ad41e7d86ea05cbafceb98abf43175f5e"></a><!-- doxytag: member="large_spi_erase_256B" ref="gga9ca3bbabf5a1d7ced0569c85206a7a84ad41e7d86ea05cbafceb98abf43175f5e" args="" -->large_spi_erase_256B</em>&nbsp;</td><td>
<p>256B page (not supported on MX25L4006E) </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga842ea04596ed9e9bfd7c2e756ca6de92"></a><!-- doxytag: member="large_flash.h::LargeSpiFlashDisable" ref="ga842ea04596ed9e9bfd7c2e756ca6de92" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LargeSpiFlashDisable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disable the Large SPI Flash library. Assumes the NVM controller is already initialised. Enables the NVM controller and restore PIOs. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing. </dd></dl>

</div>
</div>
<a class="anchor" id="ga87b0de6c91a309214687632586478feb"></a><!-- doxytag: member="large_flash.h::LargeSpiFlashEnable" ref="ga87b0de6c91a309214687632586478feb" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LargeSpiFlashEnable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable the PIOs for the Large SPI Flash library. Assumes memory is already powered up and NVM controller is not busy. Disable the NVM controller and set PIOs. </p>
<p>PARAMETERS None</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6bed9c126f0819fe4f921093e2accbbc"></a><!-- doxytag: member="large_flash.h::LargeSpiFlashEraseBlock" ref="ga6bed9c126f0819fe4f921093e2accbbc" args="(large_spi_flash_erase_size size, uint32 address, bool wait)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a> LargeSpiFlashEraseBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__NVM.html#ga9ca3bbabf5a1d7ced0569c85206a7a84">large_spi_flash_erase_size</a>&#160;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>wait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erase a single block of the Large SPI Flash device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>[in] Size of block to erase. Refer <a class="el" href="group__NVM.html#ga9ca3bbabf5a1d7ced0569c85206a7a84">large_spi_flash_erase_size</a> Note: Not all Flash devices accept all sizes. </td></tr>
    <tr><td class="paramname">address</td><td>[in] 32-bit address in block to erase (typically set to the start of the block, though some Flash devices accept any address in the block). </td></tr>
    <tr><td class="paramname">wait</td><td>[in] TRUE: Wait for the erase operation to complete FALSE: Return as soon as the erase command has been issued</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>spi_status_hardware_busy: Another operation in progress spi_status_fail: Unknown block size requested spi_status_fail_timeout: Erase operation timed out sys_status_success: Success </dd></dl>

</div>
</div>
<a class="anchor" id="ga0524d095f943a7dd0d9c2a1e9b52d666"></a><!-- doxytag: member="large_flash.h::LargeSpiFlashEraseWaitComplete" ref="ga0524d095f943a7dd0d9c2a1e9b52d666" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a> LargeSpiFlashEraseWaitComplete </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for an erase operation to complete. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>spi_status_fail_timeout: Erase operation timed out sys_status_success: Success </dd></dl>

</div>
</div>
<a class="anchor" id="gadb904fd372444c248c190d255d0f9242"></a><!-- doxytag: member="large_flash.h::LargeSpiFlashInit" ref="gadb904fd372444c248c190d255d0f9242" args="(uint16 mosi, uint16 miso, uint16 clk, uint16 ncs, uint16 pow)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LargeSpiFlashInit </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>mosi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>miso</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>clk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>ncs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>pow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configure the Large SPI Flash library. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mosi</td><td>[in] PIO to use for SPI MOSI line, or SPI_FLASH_DEFAULT_PIO for the default </td></tr>
    <tr><td class="paramname">miso</td><td>[in] PIO to use for SPI MISO line </td></tr>
    <tr><td class="paramname">clk</td><td>[in] PIO to use for SPI clock line </td></tr>
    <tr><td class="paramname">ncs</td><td>[in] PIO to use for SPI slave select line, or SPI_FLASH_DEFAULT_PIO for the default </td></tr>
    <tr><td class="paramname">pow</td><td>[in] PIO to use for NVM power control, or SPI_FLASH_DEFAULT_PIO for the default</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing. </dd></dl>

</div>
</div>
<a class="anchor" id="gae6fa5ce3fded4a53b24f90d7ec984853"></a><!-- doxytag: member="large_flash.h::LargeSpiFlashRead" ref="gae6fa5ce3fded4a53b24f90d7ec984853" args="(uint32 address, uint16 length, uint16 *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a> LargeSpiFlashRead </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"> <em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read data from the Large SPI Flash device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>[in] 32-bit address to start read from </td></tr>
    <tr><td class="paramname">length</td><td>[in] Number of octets to read </td></tr>
    <tr><td class="paramname">data</td><td>[in] Data buffer to hold data read</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>spi_status_hardware_busy: Another operation in progress spi_status_fail_timeout: Read operation timed out sys_status_success: Success </dd></dl>

</div>
</div>
<a class="anchor" id="ga1ffd46e433a7ed5953bfb33f7743ca55"></a><!-- doxytag: member="large_flash.h::LargeSpiFlashWrite" ref="ga1ffd46e433a7ed5953bfb33f7743ca55" args="(uint32 address, uint16 length, const uint16 *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a> LargeSpiFlashWrite </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16 *&#160;</td>
          <td class="paramname"> <em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write data to the Large SPI Flash device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>[in] 24-bit address to write to </td></tr>
    <tr><td class="paramname">length</td><td>[in] Number of octets to write (maximum LSF_PAGE_SIZE) </td></tr>
    <tr><td class="paramname">data</td><td>[in] Data buffer to write to Large SPI Flash device</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>spi_status_hardware_busy: Another operation in progress spi_status_page_overflow: Too much data to write in one operation spi_status_fail_timeout: Write operation timed out sys_status_success: Success </dd></dl>

</div>
</div>
<a class="anchor" id="ga573c3a61a76eda3ad848ce6f12e8cab6"></a><!-- doxytag: member="nvm.h::NvmConfigureI2cEeprom" ref="ga573c3a61a76eda3ad848ce6f12e8cab6" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a> NvmConfigureI2cEeprom </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configure the NVM manager to use an I2C EEPROM for the NVM Store. </p>
<p>CSR1000 supports both I2C EEPROM and SPI Flash boot devices, therefore the application must initialise the NVM manager with the appropriate type of device. This function is used to set up access to an I2C EEPROM device.</p>
<p>This function is typically called once, either as part of the application initialisation (in <a class="el" href="group__APP.html#ga473c6510c0fcd66f941d94c93bb7ebbe" title="Application function called after a power-on reset etc.">AppInit()</a>) or just before the first read, write, or erase access to the NVM device.</p>
<p>The CS key "I2C EEPROM Initialisation Time" defines the time required by the I2C EEPROM device after it has powered on until it is ready to operate. This figure can typically be found in the datasheet for the selected device.</p>
<p>Refer to the description of CS Key nvm_start_address and  NvmSetI2cEepromDeviceAddress usage in case EEPROM is greater than 0.5 Mbits (64 kilobytes).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status of operation </dd></dl>

</div>
</div>
<a class="anchor" id="ga32d1e4e408e0e0d3f03f0c0a75cb0b80"></a><!-- doxytag: member="nvm.h::NvmConfigureSpiFlash" ref="ga32d1e4e408e0e0d3f03f0c0a75cb0b80" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a> NvmConfigureSpiFlash </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configure the NVM manager to use a SPI Flash for the NVM Store. </p>
<p>CSR1000 supports both I2C EEPROM and SPI Flash boot devices, therefore the application must initialise the NVM manager with the appropriate type of device. This function is used to set up access to a SPI Flash device.</p>
<p>This function is typically called once, either as part of the application initialisation (in <a class="el" href="group__APP.html#ga473c6510c0fcd66f941d94c93bb7ebbe" title="Application function called after a power-on reset etc.">AppInit()</a>) or just before the first read, write, or erase access to the NVM device.</p>
<p>The CS key "SPI Flash Initialisation Time" defines the time required by the SPI Flash device after it has powered on until it is ready to operate. This figure can typically be found in the datasheet for the selected device.</p>
<p>The CS key "SPI flash block size" should be set to the size in *bytes* of a single erasable block within the SPI Flash boot device. This figure can be found in the data-sheet for the selected device. If nvm_num_spi_blocks is 2 then it's mandatory to set this CS key equal to 'flash erase sector size'.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Scenarios: 1. spi_flash_block_size is smaller than the actual erase block size and nvm_num_spi_blocks is 1 <br/>
 =&gt; Some of the storage in the flash block is unused(and thus wasted). 2. spi_flash_block_size is smaller than the actual erase block size and nvm_num_spi_blocks is 2 <br/>
 =&gt; Erase operations will span multiple NVM blocks and data corruption will occur. 3. spi_flash_block_size is larger than the actual erase block size, <br/>
 =&gt;An NVM erase will only erase part of the block, and subsequent writes to the unerased area will fail. This scenario occurs whether nvm_num_spi_blocks is 1 or 2.</dd></dl>
<p>The CS key "NVM num SPI blocks" specifies the number of consecutive erasable SPI Flash memory blocks that are available for the NVM. <br/>
 If two blocks are available, then when the first block becomes full, the SPI Flash NVM manager will be able to automatically copy the information into the second (spare) block before the first block is erased. This will reduce the chance of data corruption if the power fails during a write operation. <br/>
 If only one block is available, then when it becomes full the application will need to erase the block (and optionally copy existing data back into it) before new information can be stored. This introduces a small window in which power loss could result in loss of data.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status of operation </dd></dl>

</div>
</div>
<a class="anchor" id="gaebdda2717982f285aecda5e6b89cc4f2"></a><!-- doxytag: member="nvm.h::NvmDisable" ref="gaebdda2717982f285aecda5e6b89cc4f2" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a> NvmDisable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disable the NVM manager and power off the underlying storage device. </p>
<p>This function can be used to turn off the power to the NVM storage device. The NVM driver will retain the configuration state after powering off the device. This allows the application to subsequently call <a class="el" href="group__NVM.html#gaf3d7ab81fb92f6625c10626d3431cc52" title="Read words from the NVM Store.">NvmRead()</a>, <a class="el" href="group__NVM.html#ga9ac04e07dddce56b64b313e76a98055d" title="Write words to the NVM Store.">NvmWrite()</a>, and <a class="el" href="group__NVM.html#ga9078121290be3dee311f1ee7f33f671f" title="Erase the contents of the NVM Store.">NvmErase()</a> without having to call <a class="el" href="group__NVM.html#ga573c3a61a76eda3ad848ce6f12e8cab6" title="Configure the NVM manager to use an I2C EEPROM for the NVM Store.">NvmConfigureI2cEeprom()</a> or <a class="el" href="group__NVM.html#ga32d1e4e408e0e0d3f03f0c0a75cb0b80" title="Configure the NVM manager to use a SPI Flash for the NVM Store.">NvmConfigureSpiFlash()</a> again.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status of operation </dd></dl>

</div>
</div>
<a class="anchor" id="ga9078121290be3dee311f1ee7f33f671f"></a><!-- doxytag: member="nvm.h::NvmErase" ref="ga9078121290be3dee311f1ee7f33f671f" args="(bool erase_all)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a> NvmErase </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>erase_all</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erase the contents of the NVM Store. </p>
<p>For SPI Flash devices, if the erase_all parameter is TRUE then all firmware control information is also erased. The erase_all parameter is not used on an I2C EEPROM.</p>
<p>If the NVM device is currently disabled (via a previous call to <a class="el" href="group__NVM.html#gaebdda2717982f285aecda5e6b89cc4f2" title="Disable the NVM manager and power off the underlying storage device.">NvmDisable()</a>) it will be automatically re-enabled before the Erase operation is performed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">erase_all</td><td>SPI Flash only: erase all firmware control information as well</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status of operation </dd></dl>

</div>
</div>
<a class="anchor" id="gaf3d7ab81fb92f6625c10626d3431cc52"></a><!-- doxytag: member="nvm.h::NvmRead" ref="gaf3d7ab81fb92f6625c10626d3431cc52" args="(uint16 *buffer, uint16 length, uint16 offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a> NvmRead </td>
          <td>(</td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read words from the NVM Store. </p>
<p>Read words starting at the word offset, and store them in the supplied buffer.</p>
<p>If the NVM device is currently disabled (via a previous call to <a class="el" href="group__NVM.html#gaebdda2717982f285aecda5e6b89cc4f2" title="Disable the NVM manager and power off the underlying storage device.">NvmDisable()</a>) it will be automatically re-enabled before the Read operation is performed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to read words into </td></tr>
    <tr><td class="paramname">length</td><td>The number of words to read </td></tr>
    <tr><td class="paramname">offset</td><td>The word offset within the NVM Store to read from</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status of operation </dd></dl>

</div>
</div>
<a class="anchor" id="gab7d5bb787f030e8d6af85b4fd1539d7d"></a><!-- doxytag: member="nvm.h::NvmSetI2cEepromDeviceAddress" ref="gab7d5bb787f030e8d6af85b4fd1539d7d" args="(uint16 address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NvmSetI2cEepromDeviceAddress </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>address</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the EEPROM device address during I2C operation. </p>
<p>This sets EEPROM device address excluding the Read/Write bit. Firmware will left shift this value by 1 and set the R/W bit according to the requested operation. The default device address is 0x50.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Device address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5678c24acc660b9bd2545137b2bb31bc"></a><!-- doxytag: member="nvm.h::NvmSize" ref="ga5678c24acc660b9bd2545137b2bb31bc" args="(uint16 *size_of_storage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a> NvmSize </td>
          <td>(</td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"> <em>size_of_storage</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the size in words of the NVM Store. </p>
<p>This function can be called prior to initialising the NVM device via <a class="el" href="group__NVM.html#ga573c3a61a76eda3ad848ce6f12e8cab6" title="Configure the NVM manager to use an I2C EEPROM for the NVM Store.">NvmConfigureI2cEeprom()</a> or <a class="el" href="group__NVM.html#ga32d1e4e408e0e0d3f03f0c0a75cb0b80" title="Configure the NVM manager to use a SPI Flash for the NVM Store.">NvmConfigureSpiFlash()</a>. If it is called while the NVM device is disabled called, it will *not* re-enable the NVM device.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size_of_storage</td><td>Pointer to integer to size in</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status of operation </dd></dl>

</div>
</div>
<a class="anchor" id="ga9ac04e07dddce56b64b313e76a98055d"></a><!-- doxytag: member="nvm.h::NvmWrite" ref="ga9ac04e07dddce56b64b313e76a98055d" args="(const uint16 *buffer, uint16 length, uint16 offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a> NvmWrite </td>
          <td>(</td>
          <td class="paramtype">const uint16 *&#160;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write words to the NVM Store. </p>
<p>Write words from the supplied buffer into the NVM Store, starting at the given word offset</p>
<p>If the NVM device is currently disabled (via a previous call to <a class="el" href="group__NVM.html#gaebdda2717982f285aecda5e6b89cc4f2" title="Disable the NVM manager and power off the underlying storage device.">NvmDisable()</a>) it will be automatically re-enabled before the Write operation is performed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to write </td></tr>
    <tr><td class="paramname">length</td><td>The number of words to write </td></tr>
    <tr><td class="paramname">offset</td><td>The word offset within the NVM Store to write to</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status of operation </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Jun 22 2016 11:39:14 for CSR µEnergy&reg; Firmware by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
