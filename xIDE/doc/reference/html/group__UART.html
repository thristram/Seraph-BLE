<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CSR ÂµEnergy&reg; Firmware: UART</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>UART<br/>
<small>
[<a class="el" href="group__SERIF.html">Serial Interfaces</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>The CSR1000 includes a basic UART, capable of running across a wide range of baud rates. The UART driver can be configured to operate in unpacked (byte) mode or packed (word) mode, and utilises an non-blocking (interrupt driven) mechanism to read data received from the UART. The CSR10xx UART does not support RTS/CTS hardware flow control.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="groups"></a>
Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UartBaudrate.html">UART baudrate</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Defines used to configure the baud rate of the UART. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UartConfig.html">UART configuration</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Defines used to configure the UART. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#gabf5c73d4857d4e65c571b9abf286880c">UART_DECLARE_BUFFER</a>(_name, _size)&#160;&#160;&#160;static uint16 _name[16&lt;&lt;(_size)] GCC_ATTRIBUTE(aligned (2));</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare RAM buffer for UART RX or UART TX operation.  <a href="#gabf5c73d4857d4e65c571b9abf286880c"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef uint16(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#ga6a4e452497b935a69b96884052e8d8d9">uart_data_in_fn</a> )(void *, uint16, uint16 *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive handler function.  <a href="#ga6a4e452497b935a69b96884052e8d8d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#gac5fd37c212408a4690b681c275b0c851">uart_data_out_fn</a> )(void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit handler function.  <a href="#gac5fd37c212408a4690b681c275b0c851"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#ga208ab0a375d3c2ce71f9c830048873e2">uart_buf_size_bytes</a> { <a class="el" href="group__UART.html#gga208ab0a375d3c2ce71f9c830048873e2a5a7d645a20e505808015a81d5b614f12">UART_BUF_SIZE_BYTES_32</a> =  0, 
<a class="el" href="group__UART.html#gga208ab0a375d3c2ce71f9c830048873e2a9a7df2533dd213e66d3d1ec814562cad">UART_BUF_SIZE_BYTES_64</a> =  1, 
<a class="el" href="group__UART.html#gga208ab0a375d3c2ce71f9c830048873e2a62f29e1b632806e7eabf5d0085dc8cd5">UART_BUF_SIZE_BYTES_128</a> =  2, 
<a class="el" href="group__UART.html#gga208ab0a375d3c2ce71f9c830048873e2aea096af6ed77fc5705ecb598fa81a7b8">UART_BUF_SIZE_BYTES_256</a> =  3
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>UART buffer size, in bytes. </p>
 <a href="group__UART.html#ga208ab0a375d3c2ce71f9c830048873e2">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#ga2e4915ebabf89c196ea723cb174e2986">uart_data_mode</a> { <a class="el" href="group__UART.html#gga2e4915ebabf89c196ea723cb174e2986aad8a432343b5050d9406db5c0802a1aa">uart_data_packed</a> =  0x01, 
<a class="el" href="group__UART.html#gga2e4915ebabf89c196ea723cb174e2986acdcb3da87e26996d21ad413978b3475e">uart_data_unpacked</a> =  0x02
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>UART data mode. </p>
 <a href="group__UART.html#ga2e4915ebabf89c196ea723cb174e2986">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#ga079126f89b47a14594bc75694dd9f189">UartInit</a> (<a class="el" href="group__UART.html#ga6a4e452497b935a69b96884052e8d8d9">uart_data_in_fn</a> data_in_clbk, <a class="el" href="group__UART.html#gac5fd37c212408a4690b681c275b0c851">uart_data_out_fn</a> data_out_clbk, uint16 *rx_buffer, <a class="el" href="group__UART.html#ga208ab0a375d3c2ce71f9c830048873e2">uart_buf_size_bytes</a> rx_size_bytes, uint16 *tx_buffer, <a class="el" href="group__UART.html#ga208ab0a375d3c2ce71f9c830048873e2">uart_buf_size_bytes</a> tx_size_bytes, <a class="el" href="group__UART.html#ga2e4915ebabf89c196ea723cb174e2986">uart_data_mode</a> new_data_mode)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the UART interface.  <a href="#ga079126f89b47a14594bc75694dd9f189"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#ga3e234bb70dd8df6deb9ad2bdbb1ba538">UartEnable</a> (bool enable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable UART interface hardware.  <a href="#ga3e234bb70dd8df6deb9ad2bdbb1ba538"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#ga7085ece7da148ea83ab4ee57a7230915">UartConfig</a> (uint16 baud_rate_enum, uint16 config)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the UART baud rate and port configuration.  <a href="#ga7085ece7da148ea83ab4ee57a7230915"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#ga1f698fb9fab9c4a5857109c43c3d4668">UartRead</a> (uint16 length, uint32 timeout)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the specified amount of data from the UART.  <a href="#ga1f698fb9fab9c4a5857109c43c3d4668"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#ga77215c2e02d70e28db88754bc476bc34">UartWrite</a> (const void *data, uint16 length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a number of data bytes/words to the UART.  <a href="#ga77215c2e02d70e28db88754bc476bc34"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#ga89daf7cc17c55d7e66e6efcbfc69492a">UartWriteBlocking</a> (const void *data, uint16 length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a number of data bytes/words to the UART, blocking until all bytes have been copied to the UART transmit buffer.  <a href="#ga89daf7cc17c55d7e66e6efcbfc69492a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#ga0065c1ba69d8daa1e3d5b4e8dc168155">UartTxIsBusy</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the UART for TX activity.  <a href="#ga0065c1ba69d8daa1e3d5b4e8dc168155"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The CSR1000 includes a basic UART, capable of running across a wide range of baud rates. The UART driver can be configured to operate in unpacked (byte) mode or packed (word) mode, and utilises an non-blocking (interrupt driven) mechanism to read data received from the UART. The CSR10xx UART does not support RTS/CTS hardware flow control. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="gabf5c73d4857d4e65c571b9abf286880c"></a><!-- doxytag: member="uart.h::UART_DECLARE_BUFFER" ref="gabf5c73d4857d4e65c571b9abf286880c" args="(_name, _size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_DECLARE_BUFFER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;static uint16 _name[16&lt;&lt;(_size)] GCC_ATTRIBUTE(aligned (2));</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Declare RAM buffer for UART RX or UART TX operation. </p>
<p>This macro creates a buffer to be used by the UART interface for transmit or receive operations. The application is required to create a pair of buffers, one for RX and one for TX. The size of the buffers should be defined using one of the constants defined in <a class="el" href="group__UART.html#ga208ab0a375d3c2ce71f9c830048873e2">uart_buf_size_bytes</a>. The RX &amp; TX buffers do not need to be the same size.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The GCC alignment attribute is required when declaring buffers to ensure that the buffers meets the alignment requirements of the hardware.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_name</td><td>The name of the buffer </td></tr>
    <tr><td class="paramname">_size</td><td>The size of the buffer, using one of the constants from <a class="el" href="group__UART.html#ga208ab0a375d3c2ce71f9c830048873e2">uart_buf_size_bytes</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga6a4e452497b935a69b96884052e8d8d9"></a><!-- doxytag: member="uart.h::uart_data_in_fn" ref="ga6a4e452497b935a69b96884052e8d8d9" args=")(void *, uint16, uint16 *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint16(* <a class="el" href="group__UART.html#ga6a4e452497b935a69b96884052e8d8d9">uart_data_in_fn</a>)(void *, uint16, uint16 *)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receive handler function. </p>
<p>A function that will be called whenever <code>length</code> number of bytes (which is set by uart_fetch_data or <a class="el" href="group__DBG.html#ga8f0ddc73d6b7f1571f80cecd60a0771c">DebugInit</a>) have been received over the UART.</p>
<p>The function takes three parameters: a pointer to a <code>void</code> buffer of the received data (which will be a uint8* if the UART data mode is 'unpacked' or a uint16* if the UART data mode is 'packed'), a <code>uint16</code> containing the number of bytes ('unpacked') or words ('packed') received, and a pointer to a <code>uint16</code> which should be filled in with the number of additional bytes ('unpacked') or words ('packed') the application wishes to receive (set to 0 if no further data is required at this time).</p>
<p>The function must return the number of bytes ('unpacked') or words ('packed') that the application has processed out of the available data (which may be less than was originally provided to the application). If the application does not process all of the data then the remaining data will remain in the buffer until a further amount of data requested by the application has been received.</p>
<p>NOTE: The application does not have to check for wrapping within the UART RX circular buffer. The memory management hardware ensures that the the data pointer supplied to the application presents the received data sequentially.</p>
<p>If the callback function is NULL, it indicates that the application is not interested in receiving data. </p>

</div>
</div>
<a class="anchor" id="gac5fd37c212408a4690b681c275b0c851"></a><!-- doxytag: member="uart.h::uart_data_out_fn" ref="gac5fd37c212408a4690b681c275b0c851" args=")(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="group__UART.html#gac5fd37c212408a4690b681c275b0c851">uart_data_out_fn</a>)(void)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transmit handler function. </p>
<p>A function that will be called whenever a UART transmission has finished. The function takes no parameters and must return no value.</p>
<p>May be NULL, which indicates that these events are uninteresting to the application. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga208ab0a375d3c2ce71f9c830048873e2"></a><!-- doxytag: member="uart.h::uart_buf_size_bytes" ref="ga208ab0a375d3c2ce71f9c830048873e2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__UART.html#ga208ab0a375d3c2ce71f9c830048873e2">uart_buf_size_bytes</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>UART buffer size, in bytes. </p>
<p>These constants represent the possible size of UART buffers that be created. No other buffer sizes are supported by the UART interface. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga208ab0a375d3c2ce71f9c830048873e2a5a7d645a20e505808015a81d5b614f12"></a><!-- doxytag: member="UART_BUF_SIZE_BYTES_32" ref="gga208ab0a375d3c2ce71f9c830048873e2a5a7d645a20e505808015a81d5b614f12" args="" -->UART_BUF_SIZE_BYTES_32</em>&nbsp;</td><td>
<p>32 byte buffer </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga208ab0a375d3c2ce71f9c830048873e2a9a7df2533dd213e66d3d1ec814562cad"></a><!-- doxytag: member="UART_BUF_SIZE_BYTES_64" ref="gga208ab0a375d3c2ce71f9c830048873e2a9a7df2533dd213e66d3d1ec814562cad" args="" -->UART_BUF_SIZE_BYTES_64</em>&nbsp;</td><td>
<p>64 byte buffer </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga208ab0a375d3c2ce71f9c830048873e2a62f29e1b632806e7eabf5d0085dc8cd5"></a><!-- doxytag: member="UART_BUF_SIZE_BYTES_128" ref="gga208ab0a375d3c2ce71f9c830048873e2a62f29e1b632806e7eabf5d0085dc8cd5" args="" -->UART_BUF_SIZE_BYTES_128</em>&nbsp;</td><td>
<p>128 byte buffer </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga208ab0a375d3c2ce71f9c830048873e2aea096af6ed77fc5705ecb598fa81a7b8"></a><!-- doxytag: member="UART_BUF_SIZE_BYTES_256" ref="gga208ab0a375d3c2ce71f9c830048873e2aea096af6ed77fc5705ecb598fa81a7b8" args="" -->UART_BUF_SIZE_BYTES_256</em>&nbsp;</td><td>
<p>256 byte buffer </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2e4915ebabf89c196ea723cb174e2986"></a><!-- doxytag: member="uart.h::uart_data_mode" ref="ga2e4915ebabf89c196ea723cb174e2986" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__UART.html#ga2e4915ebabf89c196ea723cb174e2986">uart_data_mode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>UART data mode. </p>
<p>The UART can be operated in packed or unpacked mode. By default the UART is unpacked, but the application can change this by calling <a class="el" href="group__UartConfig.html">UART configuration</a>. The data mode affects the type of data passed from application to UART via the <a class="el" href="group__UART.html#ga77215c2e02d70e28db88754bc476bc34">UartWrite</a> or <a class="el" href="group__UART.html#ga89daf7cc17c55d7e66e6efcbfc69492a">UartWriteBlocking</a> functions, and the type of data passed back from the UART to application in the <a class="el" href="group__UART.html#ga1f698fb9fab9c4a5857109c43c3d4668" title="Read the specified amount of data from the UART.">UartRead()</a> callback function.</p>
<p>The data mode does not affect the TX &amp; RX buffers passed to <a class="el" href="group__UART.html#ga079126f89b47a14594bc75694dd9f189">UartInit</a> - these buffers are always packed uint16 buffers, with the UART driver unpacking &amp; packing data as required. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga2e4915ebabf89c196ea723cb174e2986aad8a432343b5050d9406db5c0802a1aa"></a><!-- doxytag: member="uart_data_packed" ref="gga2e4915ebabf89c196ea723cb174e2986aad8a432343b5050d9406db5c0802a1aa" args="" -->uart_data_packed</em>&nbsp;</td><td>
<p>UART data is packed (arrays of uint16) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga2e4915ebabf89c196ea723cb174e2986acdcb3da87e26996d21ad413978b3475e"></a><!-- doxytag: member="uart_data_unpacked" ref="gga2e4915ebabf89c196ea723cb174e2986acdcb3da87e26996d21ad413978b3475e" args="" -->uart_data_unpacked</em>&nbsp;</td><td>
<p>UART data is unpacked (arrays of uint8) </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga7085ece7da148ea83ab4ee57a7230915"></a><!-- doxytag: member="uart.h::UartConfig" ref="ga7085ece7da148ea83ab4ee57a7230915" args="(uint16 baud_rate_enum, uint16 config)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UartConfig </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>baud_rate_enum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configure the UART baud rate and port configuration. </p>
<p>After calling this function the UART will be left disabled. The caller must therefore call <a class="el" href="group__UART.html#ga3e234bb70dd8df6deb9ad2bdbb1ba538">UartEnable</a> before transmitting or receiving any data.</p>
<p>If the baud rate is set to UART_RATE_DEFAULT then the baud rate and port configuration will be read from the corresponding Configuration Store keys.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">baud_rate_enum</td><td>Described by <a class="el" href="group__UartBaudrate.html">UART baudrate</a>. </td></tr>
    <tr><td class="paramname">config</td><td>A 16-bit bitfield described by <a class="el" href="group__UartConfig.html">UART configuration</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3e234bb70dd8df6deb9ad2bdbb1ba538"></a><!-- doxytag: member="uart.h::UartEnable" ref="ga3e234bb70dd8df6deb9ad2bdbb1ba538" args="(bool enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UartEnable </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>enable</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable/disable UART interface hardware. </p>
<p>Enabling the UART interface defaults to waking the CSR1000 when it receives RX data (see <a class="el" href="group__PWRMGMT.html#ga7a75a9a70ec1d0831ee3cefbd4db1c7a">SleepWakeOnUartRX</a>).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>TRUE to enable, FALSE to disable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga079126f89b47a14594bc75694dd9f189"></a><!-- doxytag: member="uart.h::UartInit" ref="ga079126f89b47a14594bc75694dd9f189" args="(uart_data_in_fn data_in_clbk, uart_data_out_fn data_out_clbk, uint16 *rx_buffer, uart_buf_size_bytes rx_size_bytes, uint16 *tx_buffer, uart_buf_size_bytes tx_size_bytes, uart_data_mode new_data_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UartInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__UART.html#ga6a4e452497b935a69b96884052e8d8d9">uart_data_in_fn</a>&#160;</td>
          <td class="paramname"> <em>data_in_clbk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__UART.html#gac5fd37c212408a4690b681c275b0c851">uart_data_out_fn</a>&#160;</td>
          <td class="paramname"> <em>data_out_clbk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"> <em>rx_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__UART.html#ga208ab0a375d3c2ce71f9c830048873e2">uart_buf_size_bytes</a>&#160;</td>
          <td class="paramname"> <em>rx_size_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"> <em>tx_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__UART.html#ga208ab0a375d3c2ce71f9c830048873e2">uart_buf_size_bytes</a>&#160;</td>
          <td class="paramname"> <em>tx_size_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__UART.html#ga2e4915ebabf89c196ea723cb174e2986">uart_data_mode</a>&#160;</td>
          <td class="paramname"> <em>new_data_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialise the UART interface. </p>
<p>Sets the function pointers to be called on data in/out events. Defines the TX &amp; RX buffers (start address and size for each buffer). RX &amp; TX buffers are normally declared using the <a class="el" href="group__UART.html#gabf5c73d4857d4e65c571b9abf286880c">UART_DECLARE_BUFFER</a> macro. If the application wants to use the UART in 'packed' mode (see <a class="el" href="group__UartConfig.html">UART configuration</a>) it must still provide the length of the TX &amp; RX buffers to this function in bytes. The rx_size and tx_size parameters are an enum <a class="el" href="group__UART.html#ga208ab0a375d3c2ce71f9c830048873e2">uart_buf_size_bytes</a> to restrict the possible values that these parameters can accept.</p>
<p>This function also configures the UART with the default settings stored in the CS keys. If the application wishes to change the port configuration it should call <a class="el" href="group__UartConfig.html">UART configuration</a> after calling this function.</p>
<p>The application may provide NULL pointers for the data in and/or data out events, if it it does not care about receiving and/or transmitting data. For example, a simple debug interface that only uses the UART to send debug messages would not need an RX callback at all, and would likely not need a TX callback either.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The UART interface only supports buffers of size 32, 64, 128, or 256 bytes. If the application tries to create a buffer that is a different size the UART interface will generate a fault.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data_in_clbk</td><td>Pointer to a function of type <a class="el" href="group__UART.html#ga6a4e452497b935a69b96884052e8d8d9">uart_data_in_fn</a>. </td></tr>
    <tr><td class="paramname">data_out_clbk</td><td>Pointer to a function of type <a class="el" href="group__UART.html#gac5fd37c212408a4690b681c275b0c851">uart_data_out_fn</a>. </td></tr>
    <tr><td class="paramname">rx_buffer</td><td>Pointer to the RX (read) buffer </td></tr>
    <tr><td class="paramname">rx_size_bytes</td><td>Size of the RX buffer </td></tr>
    <tr><td class="paramname">tx_buffer</td><td>Pointer to the TX (write) buffer </td></tr>
    <tr><td class="paramname">tx_size_bytes</td><td>Size of the TX buffer </td></tr>
    <tr><td class="paramname">data_mode</td><td>Desired data packing mode for UART (unpacked or packed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1f698fb9fab9c4a5857109c43c3d4668"></a><!-- doxytag: member="uart.h::UartRead" ref="ga1f698fb9fab9c4a5857109c43c3d4668" args="(uint16 length, uint32 timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UartRead </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"> <em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read the specified amount of data from the UART. </p>
<p>Requests that the UART driver returns the specified amount of received UART data to the application once said amount of data is available. The actual data is made available to the caller via the <code>data_in_clbk</code> function that was registered with <a class="el" href="group__UART.html#ga079126f89b47a14594bc75694dd9f189">UartInit</a>.</p>
<p>The length parameter depends on the current UART data mode ('unpacked' or 'packed'). For packed data, the length is the number of words to read, therefore the UART driver will wait until an even number of bytes have been received over the wire (for example if the application has set 'packed' mode and requests length=4, the driver will wait until 4 words have been received (8 bytes) before calling the <code>data_in_clbk</code> callback function). When the UART data mode is 'unpacked' the length parameter is the number of bytes to receive.</p>
<p>If the application has not provided an RX callback function in <a class="el" href="group__UART.html#ga079126f89b47a14594bc75694dd9f189" title="Initialise the UART interface.">UartInit()</a> then requesting a read of an amount of data will result in that data being read from the UART buffer and discarded. However, as the application does not receive any event when this happens it should not be used to "empty" the UART buffer, as there is no way for the application to determine exactly how much data has been discarded.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The data pointer passed to the application in the <code>data_in_clbk</code> must not be used directly for writing data straight back to the UART. If the application needs to implement a loopback mechanism it must first copy the received data to a local buffer and then use that as the source for the data passed to <a class="el" href="group__UART.html#ga77215c2e02d70e28db88754bc476bc34">UartWrite</a>.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>Amount of data to get (in bytes or words depending on UART data mode). </td></tr>
    <tr><td class="paramname">timeout</td><td>Not currently used. Must always be set to 0 by the application </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0065c1ba69d8daa1e3d5b4e8dc168155"></a><!-- doxytag: member="uart.h::UartTxIsBusy" ref="ga0065c1ba69d8daa1e3d5b4e8dc168155" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UartTxIsBusy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check the UART for TX activity. </p>
<p>Returns TRUE if the UART is transmitting a packet.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This function is not intended for customer use. </dd></dl>

</div>
</div>
<a class="anchor" id="ga77215c2e02d70e28db88754bc476bc34"></a><!-- doxytag: member="uart.h::UartWrite" ref="ga77215c2e02d70e28db88754bc476bc34" args="(const void *data, uint16 length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UartWrite </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a number of data bytes/words to the UART. </p>
<p>Given a pointer to an array, write this data into the UART's transmit buffer and initiate the UART transmit. The length parameter is the number of array "elements" to be written - depending on the UART mode this is either the number of bytes (uart_data_unpacked) or number of words (uart_data_packed).</p>
<p>The size of each element of array is defined by the current data mode of the UART (see <a class="el" href="group__UART.html#ga079126f89b47a14594bc75694dd9f189">UartInit</a> and <a class="el" href="group__UART.html#ga2e4915ebabf89c196ea723cb174e2986">uart_data_mode</a>). If the data mode is <code>uart_data_unpacked</code> then the <code>data</code> pointer is assumed to point to an array of (unpacked) uint8 data, and the LSB of each element will be copied into the UART transmit buffer. If the data mode is <code>uart_data_packed</code> then the <code>data</code> pointer is assumed to point to (packed) uint16 data and the LSB and MSB of each word will be copied into the UART transmit buffer, LSB first.</p>
<p>This function will return without writing any data if the internal transmit buffer does not have enough space to store all of the data. To ensure that the data is written on the first attempt (blocking write behaviour), the <a class="el" href="group__UART.html#ga89daf7cc17c55d7e66e6efcbfc69492a">UartWriteBlocking</a> function must be used instead. (The application must not use a while() loop to "poll" the <a class="el" href="group__UART.html#ga77215c2e02d70e28db88754bc476bc34" title="Write a number of data bytes/words to the UART.">UartWrite()</a> function as doing so will not allow the UART to clean up after existing bytes have been transmitted).</p>
<p>INTERRUPTS: This function is non-reentrant.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The data pointer passed to the application in the <code>data_in_clbk</code> must not be used directly for writing data straight back to the UART. If the application needs to implement a loopback mechanism it must first copy the received data to a local buffer and then use that as the source for the data passed to <a class="el" href="group__UART.html#ga77215c2e02d70e28db88754bc476bc34">UartWrite</a>.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to the data buffer </td></tr>
    <tr><td class="paramname">length</td><td>Length of data</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success or FALSE if there was insufficient space in the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="ga89daf7cc17c55d7e66e6efcbfc69492a"></a><!-- doxytag: member="uart.h::UartWriteBlocking" ref="ga89daf7cc17c55d7e66e6efcbfc69492a" args="(const void *data, uint16 length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UartWriteBlocking </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a number of data bytes/words to the UART, blocking until all bytes have been copied to the UART transmit buffer. </p>
<p>This function behaves very much like <a class="el" href="group__UART.html#ga77215c2e02d70e28db88754bc476bc34">UartWrite</a>, with the exception that it will not return until all the data has been copied to the UART transmit buffer. Therefore there is no return value (it will always succeed).</p>
<p>NOTE: If the buffer is full when called, then the time taken to return will depend on how much data needs to be emptied before the all of the new data can be stored in the UART buffer, and the baud rate of the UART (which controls how quickly the hardware can transmit the contents of the transmit buffer over the wire).</p>
<p>INTERRUPTS: This function is non-reentrant.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This function will return when all supplied bytes have been buffered by the UART. This is not the same as having actually transmitted all bytes over the wire.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to the data buffer </td></tr>
    <tr><td class="paramname">length</td><td>Length of data</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Jun 22 2016 11:39:14 for CSR ÂµEnergy&reg; Firmware by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
