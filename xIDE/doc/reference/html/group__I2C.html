<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CSR ÂµEnergy&reg; Firmware: I2C Serial Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#enumval-members">Enumerator</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>I2C Serial Interface<br/>
<small>
[<a class="el" href="group__SERIF.html">Serial Interfaces</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>The I2C library functions provide access to I2C devices attached to the dedicated I2C bus or any group of PIOs. The CSR1000 acts as an I2C Bus Master. The library supports generic access to any device that appears as a standard I2C EEPROM (i.e. real EEPROM devices or other peripherals that provide a memory-mapped register interface). For devices that use a non-standard protocol, raw access to the I2C bus is also available, allowing the application to generate discrete I2C conditions such as START, RESTART, STOP, ACKs and NACKs, and send or receive individual bytes.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga699cee3c0b2cc2e8ab4dfb355179709b">I2C_RESERVED_PIO</a>&#160;&#160;&#160;0xFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">PIO selection to use dedicated I2C bus pins instead of general purpose PIOs.  <a href="#ga699cee3c0b2cc2e8ab4dfb355179709b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga969d15be24cb0b1fe267f664820eab90">I2C_POWER_PIO_UNDEFINED</a>&#160;&#160;&#160;0xFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">PIO value indicating that the I2C device driver should not manage the power for the I2C device(s).  <a href="#ga969d15be24cb0b1fe267f664820eab90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gadf1fd784a8d977994cf5f8f6fcd6f8d5">I2C_EEPROM_POLLED_WRITE_CYCLE</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This constant can be used when setting the EEPROM Write Cycle Time with <a class="el" href="group__I2C.html#ga95d66c188ad80a22d138a181c0cdb5b7" title="Set the EEPROM write cycle time (in microseconds).">I2cEepromSetWriteCycleTime()</a> to indicate that the I2C driver should poll the EEPROM for write completion instead of waiting a fixed period.  <a href="#gadf1fd784a8d977994cf5f8f6fcd6f8d5"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga0838ceb9488b3ce18ed2c076d9ce9e7a">i2c_command</a> { <br/>
&#160;&#160;<a class="el" href="group__I2C.html#gga0838ceb9488b3ce18ed2c076d9ce9e7aa0551f14633e9a4c957f5dab457ecd584">i2c_cmd_send_start</a> =  0x00, 
<a class="el" href="group__I2C.html#gga0838ceb9488b3ce18ed2c076d9ce9e7aa031ee7043a4acea53c318e4c887fe954">i2c_cmd_send_restart</a> =  0x01, 
<a class="el" href="group__I2C.html#gga0838ceb9488b3ce18ed2c076d9ce9e7aa8802d6ff751df38d08a3085eb428261c">i2c_cmd_send_stop</a> =  0x02, 
<a class="el" href="group__I2C.html#gga0838ceb9488b3ce18ed2c076d9ce9e7aa0997f08cce263c6be0702e893af14ae6">i2c_cmd_wait_ack</a> =  0x03, 
<br/>
&#160;&#160;<a class="el" href="group__I2C.html#gga0838ceb9488b3ce18ed2c076d9ce9e7aa0c213ffe918bfb73fe1e027944a81f9f">i2c_cmd_send_ack</a> =  0x04, 
<a class="el" href="group__I2C.html#gga0838ceb9488b3ce18ed2c076d9ce9e7aaf9f8a3d1ef256a43b22393f586acfa91">i2c_cmd_send_nack</a> =  0x05, 
<a class="el" href="group__I2C.html#gga0838ceb9488b3ce18ed2c076d9ce9e7aa6f19f2a89c6713dfe792695608381785">i2c_cmd_tx_data</a> =  0x06, 
<a class="el" href="group__I2C.html#gga0838ceb9488b3ce18ed2c076d9ce9e7aa9ef1cdea15f1857ba8589b963f352a22">i2c_cmd_rx_data</a> =  0x07
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Raw I2C commands. </p>
 <a href="group__I2C.html#ga0838ceb9488b3ce18ed2c076d9ce9e7a">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga5bf91001b79485a43b0ef1bfee9d58a5">I2cInit</a> (uint8 sda_pio, uint8 scl_pio, uint8 power_pio, <a class="el" href="group__PIO__B.html#ga8e3150c3867c3218db866f0c1862074e">pio_pull_mode</a> pull)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the I2C library.  <a href="#ga5bf91001b79485a43b0ef1bfee9d58a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gaf49bebc525106fe161824a3a093b4bf2">I2cConfigClock</a> (uint8 scl_high, uint8 scl_low)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the high and low periods of the I2C clock.  <a href="#gaf49bebc525106fe161824a3a093b4bf2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gabdf886596abe1dad7baf697143d17588">I2cEnable</a> (bool enable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the I2C controller.  <a href="#gabdf886596abe1dad7baf697143d17588"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga5d7ec5f88f785c09d1638e324f0b89b2">I2cReady</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Test to see if the current I2C transaction has completed.  <a href="#ga5d7ec5f88f785c09d1638e324f0b89b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga486888f4abd18ff7630d8c734bbca80a"></a><!-- doxytag: member="I2C::I2cWaitReady" ref="ga486888f4abd18ff7630d8c734bbca80a" args="(void)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga486888f4abd18ff7630d8c734bbca80a">I2cWaitReady</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Busy-wait until the current I2C transaction has completed. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga4fda2ce4cde1367d286aeba7f2648837">I2cReset</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the I2C controller.  <a href="#ga4fda2ce4cde1367d286aeba7f2648837"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga45a16eb8525adef8635eede7249a6be5">I2cEepromSetWritePageSize</a> (uint16 page_size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the EEPROM page size for write operations.  <a href="#ga45a16eb8525adef8635eede7249a6be5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga95d66c188ad80a22d138a181c0cdb5b7">I2cEepromSetWriteCycleTime</a> (uint16 cycle_time)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the EEPROM write cycle time (in microseconds).  <a href="#ga95d66c188ad80a22d138a181c0cdb5b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gaa181563246248aaf6473629893f0876a">I2cEepromRead</a> (uint16 device, uint16 address, bool wait, uint16 length, uint16 *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read bytes from a standard I2C EEPROM.  <a href="#gaa181563246248aaf6473629893f0876a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga85dbb9d66d9207910e6017e15220830f">I2cEepromReadComplete</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish writing bytes to the I2C bus.  <a href="#ga85dbb9d66d9207910e6017e15220830f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga20dba0770393f239b60f789ea3b4f4f4">I2cEepromWrite</a> (uint16 device, uint16 address, bool wait, uint16 length, const uint16 *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write bytes to a standard I2C EEPROM.  <a href="#ga20dba0770393f239b60f789ea3b4f4f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gaa9fb17504925ce9198259b8e557ef67d">I2cRawCommand</a> (<a class="el" href="group__I2C.html#ga0838ceb9488b3ce18ed2c076d9ce9e7a">i2c_command</a> cmd, bool wait, uint16 timeout)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a raw I2C command to I2C controller.  <a href="#gaa9fb17504925ce9198259b8e557ef67d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga23925a0f653ed9905a2872c98f34443d">I2cRawComplete</a> (uint16 timeout)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the last issued I2C command to complete.  <a href="#ga23925a0f653ed9905a2872c98f34443d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga0955f7ed53902b8ba8e09b13a2500af5">I2cRawTerminate</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends the sequence of I2C raw commands.  <a href="#ga0955f7ed53902b8ba8e09b13a2500af5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga2cefeecf965f91fb1373d03e4cbb6f46">I2cRawReadByte</a> (uint8 *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a byte of data from the I2C bus.  <a href="#ga2cefeecf965f91fb1373d03e4cbb6f46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga87a181186f86c3dfbdd3bc999e74a814">I2cRawRead</a> (uint8 *data, uint16 length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the I2C bus, ACKing received bytes and NACKing the last byte.  <a href="#ga87a181186f86c3dfbdd3bc999e74a814"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga5eebec1901354d7206f9f98ec04285b0">I2cRawWriteByte</a> (uint8 data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a byte of data to the I2C bus.  <a href="#ga5eebec1901354d7206f9f98ec04285b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gac84164887f158a64c866d0828e04bb7c">I2cRawWrite</a> (const uint8 *data, uint16 length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to the I2C bus, waiting for ACK after each byte.  <a href="#gac84164887f158a64c866d0828e04bb7c"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
I2C Clock Configurations</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpcf3698ea2d41532941a3c427d27c068e"></a>Standard I2C clock configurations for 100kHz and 400kHz operation, optimised for EEPROM devices.</p>
<p>These constants can be used when calling <a class="el" href="group__I2C.html#gaf49bebc525106fe161824a3a093b4bf2">I2cConfigClock()</a> if the values are suitable for use with the I2C device.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Customers are advised to always confirm device timing requirements in the datasheet for the I2C device used in their product. These default clock values are specified for use with the parts used in CSR10xx reference designs. However other devices may have different minimum times for the high and low periods of SCL. In particular some devices require more time low than high, hence the values defined here do not result in a perfectly square clock signal at 400kHz, in order to optimise the timing for these devices. (Whereas at 100kHz it is possible to use the same periods for SCL high and SCL low, resulting in a square clock signal). </dd></dl>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gae90ae7747a1e2c84124172845f063a61">I2C_SCL_100KBPS_HIGH_PERIOD</a>&#160;&#160;&#160;78</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga57ef89c1e09ddf1ca71cf48761a0080b">I2C_SCL_100KBPS_LOW_PERIOD</a>&#160;&#160;&#160;78</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gaf3125dba4490c8743d9f80b7ce86a175">I2C_SCL_400KBPS_HIGH_PERIOD</a>&#160;&#160;&#160;15</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gaf33b23cc933067b02e79ade1ab073485">I2C_SCL_400KBPS_LOW_PERIOD</a>&#160;&#160;&#160;21</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
I2C Timeouts</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp045a02111139e7f229e7052b51b86ea3"></a>Default timeouts for I2C operations. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa43abf02123338965be004b86ec04493"></a><!-- doxytag: member="I2C::I2C_WAIT_ACK_TIMEOUT" ref="gaa43abf02123338965be004b86ec04493" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>I2C_WAIT_ACK_TIMEOUT</b>&#160;&#160;&#160;(1UL * MILLISECOND)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaed7237cf0e5d5b346aa25f58664e5d4f"></a><!-- doxytag: member="I2C::I2C_WAIT_CMD_TIMEOUT" ref="gaed7237cf0e5d5b346aa25f58664e5d4f" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>I2C_WAIT_CMD_TIMEOUT</b>&#160;&#160;&#160;(1UL * MILLISECOND)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
I2C Raw Commands</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp97b03b1792fcef23dc91c28836c01d6f"></a>Send raw commands to the I2C controller.</p>
<p>These macros are used to send START, RESTART, STOP, ACK, or NACK over the I2C bus, or wait for an ACK for the addressed slave.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">wait</td><td>TRUE if the function should wait for the transaction to complete </td></tr>
  </table>
  </dd>
</dl>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga5112ec824d21b94e7d06517a7b2d754a">I2cRawStart</a>(wait)&#160;&#160;&#160;I2cRawCommand(i2c_cmd_send_start, wait, I2C_WAIT_CMD_TIMEOUT)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga06f1d8098edae6e6807bfa07c198f2d1">I2cRawRestart</a>(wait)&#160;&#160;&#160;I2cRawCommand(i2c_cmd_send_restart, wait, I2C_WAIT_CMD_TIMEOUT)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gaa23c54885cb47ac7b83186e9d3e83107">I2cRawStop</a>(wait)&#160;&#160;&#160;I2cRawCommand(i2c_cmd_send_stop, wait, I2C_WAIT_CMD_TIMEOUT)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga595d24eb72bb905443b7c1b4e9f8d27d">I2cRawWaitAck</a>(wait)&#160;&#160;&#160;I2cRawCommand(i2c_cmd_wait_ack, wait, I2C_WAIT_ACK_TIMEOUT)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga63b4fbdd13fabef7732fbca0a6480648">I2cRawSendAck</a>(wait)&#160;&#160;&#160;I2cRawCommand(i2c_cmd_send_ack, wait, I2C_WAIT_CMD_TIMEOUT)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gae8b3150424d65e4ba8ebf84a08268446">I2cRawSendNack</a>(wait)&#160;&#160;&#160;I2cRawCommand(i2c_cmd_send_nack, wait, I2C_WAIT_CMD_TIMEOUT)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The I2C library functions provide access to I2C devices attached to the dedicated I2C bus or any group of PIOs. The CSR1000 acts as an I2C Bus Master. The library supports generic access to any device that appears as a standard I2C EEPROM (i.e. real EEPROM devices or other peripherals that provide a memory-mapped register interface). For devices that use a non-standard protocol, raw access to the I2C bus is also available, allowing the application to generate discrete I2C conditions such as START, RESTART, STOP, ACKs and NACKs, and send or receive individual bytes. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="gadf1fd784a8d977994cf5f8f6fcd6f8d5"></a><!-- doxytag: member="i2c.h::I2C_EEPROM_POLLED_WRITE_CYCLE" ref="gadf1fd784a8d977994cf5f8f6fcd6f8d5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_EEPROM_POLLED_WRITE_CYCLE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This constant can be used when setting the EEPROM Write Cycle Time with <a class="el" href="group__I2C.html#ga95d66c188ad80a22d138a181c0cdb5b7" title="Set the EEPROM write cycle time (in microseconds).">I2cEepromSetWriteCycleTime()</a> to indicate that the I2C driver should poll the EEPROM for write completion instead of waiting a fixed period. </p>
<p>The EEPROM Write Cycle Time is the period of time to wait at the end of an EEPROM write transaction to allow the write to complete within the device. Some EEPROMs support a mode where they will not ACKnowledge any further activity during this internal write cycle, which allows the EEPROM driver to poll them and return immediately after the write has completed rather than waiting a fixed length of time (which, depending on the device, may be quite pessimistic in normal operating conditions).</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>To avoid a software lock-up due to an unresponsive EEPROM, the driver will abort polling and return if the EEPROM has not generated an ACK within 64ms. If this happens status <a class="el" href="group__STAT.html#gga4d0e4416aa801fbed0a19d3d24fdbba6a8fe48e88d5ad2e79697116c71ea59c04">i2c_status_fail_write_poll_timeout</a> will be returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ga969d15be24cb0b1fe267f664820eab90"></a><!-- doxytag: member="i2c.h::I2C_POWER_PIO_UNDEFINED" ref="ga969d15be24cb0b1fe267f664820eab90" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_POWER_PIO_UNDEFINED&#160;&#160;&#160;0xFF</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>PIO value indicating that the I2C device driver should not manage the power for the I2C device(s). </p>
<p>This constant can be used when calling <a class="el" href="group__I2C.html#ga5bf91001b79485a43b0ef1bfee9d58a5">I2cInit()</a>. </p>

</div>
</div>
<a class="anchor" id="ga699cee3c0b2cc2e8ab4dfb355179709b"></a><!-- doxytag: member="i2c.h::I2C_RESERVED_PIO" ref="ga699cee3c0b2cc2e8ab4dfb355179709b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_RESERVED_PIO&#160;&#160;&#160;0xFF</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>PIO selection to use dedicated I2C bus pins instead of general purpose PIOs. </p>
<p>This constant can be used when calling <a class="el" href="group__I2C.html#ga5bf91001b79485a43b0ef1bfee9d58a5">I2cInit()</a> if the application wants to use the reserved I2C pins for the I2C clock or data signals. </p>

</div>
</div>
<a class="anchor" id="gae90ae7747a1e2c84124172845f063a61"></a><!-- doxytag: member="i2c.h::I2C_SCL_100KBPS_HIGH_PERIOD" ref="gae90ae7747a1e2c84124172845f063a61" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_SCL_100KBPS_HIGH_PERIOD&#160;&#160;&#160;78</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>SCL high period for 100kHz clock </p>

</div>
</div>
<a class="anchor" id="ga57ef89c1e09ddf1ca71cf48761a0080b"></a><!-- doxytag: member="i2c.h::I2C_SCL_100KBPS_LOW_PERIOD" ref="ga57ef89c1e09ddf1ca71cf48761a0080b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_SCL_100KBPS_LOW_PERIOD&#160;&#160;&#160;78</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>SCL low period for 100kHz clock </p>

</div>
</div>
<a class="anchor" id="gaf3125dba4490c8743d9f80b7ce86a175"></a><!-- doxytag: member="i2c.h::I2C_SCL_400KBPS_HIGH_PERIOD" ref="gaf3125dba4490c8743d9f80b7ce86a175" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_SCL_400KBPS_HIGH_PERIOD&#160;&#160;&#160;15</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>SCL high period for 400kHz clock </p>

</div>
</div>
<a class="anchor" id="gaf33b23cc933067b02e79ade1ab073485"></a><!-- doxytag: member="i2c.h::I2C_SCL_400KBPS_LOW_PERIOD" ref="gaf33b23cc933067b02e79ade1ab073485" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_SCL_400KBPS_LOW_PERIOD&#160;&#160;&#160;21</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>SCL low period for 400kHz clock </p>

</div>
</div>
<a class="anchor" id="ga06f1d8098edae6e6807bfa07c198f2d1"></a><!-- doxytag: member="i2c.h::I2cRawRestart" ref="ga06f1d8098edae6e6807bfa07c198f2d1" args="(wait)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2cRawRestart</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">wait&#160;)</td>
          <td>&#160;&#160;&#160;I2cRawCommand(i2c_cmd_send_restart, wait, I2C_WAIT_CMD_TIMEOUT)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send a RESTART condition </p>

</div>
</div>
<a class="anchor" id="ga63b4fbdd13fabef7732fbca0a6480648"></a><!-- doxytag: member="i2c.h::I2cRawSendAck" ref="ga63b4fbdd13fabef7732fbca0a6480648" args="(wait)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2cRawSendAck</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">wait&#160;)</td>
          <td>&#160;&#160;&#160;I2cRawCommand(i2c_cmd_send_ack, wait, I2C_WAIT_CMD_TIMEOUT)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send an ACK condition </p>

</div>
</div>
<a class="anchor" id="gae8b3150424d65e4ba8ebf84a08268446"></a><!-- doxytag: member="i2c.h::I2cRawSendNack" ref="gae8b3150424d65e4ba8ebf84a08268446" args="(wait)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2cRawSendNack</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">wait&#160;)</td>
          <td>&#160;&#160;&#160;I2cRawCommand(i2c_cmd_send_nack, wait, I2C_WAIT_CMD_TIMEOUT)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send a NACK condition </p>

</div>
</div>
<a class="anchor" id="ga5112ec824d21b94e7d06517a7b2d754a"></a><!-- doxytag: member="i2c.h::I2cRawStart" ref="ga5112ec824d21b94e7d06517a7b2d754a" args="(wait)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2cRawStart</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">wait&#160;)</td>
          <td>&#160;&#160;&#160;I2cRawCommand(i2c_cmd_send_start, wait, I2C_WAIT_CMD_TIMEOUT)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send a START condition </p>

</div>
</div>
<a class="anchor" id="gaa23c54885cb47ac7b83186e9d3e83107"></a><!-- doxytag: member="i2c.h::I2cRawStop" ref="gaa23c54885cb47ac7b83186e9d3e83107" args="(wait)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2cRawStop</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">wait&#160;)</td>
          <td>&#160;&#160;&#160;I2cRawCommand(i2c_cmd_send_stop, wait, I2C_WAIT_CMD_TIMEOUT)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send a STOP condition </p>

</div>
</div>
<a class="anchor" id="ga595d24eb72bb905443b7c1b4e9f8d27d"></a><!-- doxytag: member="i2c.h::I2cRawWaitAck" ref="ga595d24eb72bb905443b7c1b4e9f8d27d" args="(wait)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2cRawWaitAck</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">wait&#160;)</td>
          <td>&#160;&#160;&#160;I2cRawCommand(i2c_cmd_wait_ack, wait, I2C_WAIT_ACK_TIMEOUT)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wait for an ACK </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga0838ceb9488b3ce18ed2c076d9ce9e7a"></a><!-- doxytag: member="i2c.h::i2c_command" ref="ga0838ceb9488b3ce18ed2c076d9ce9e7a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__I2C.html#ga0838ceb9488b3ce18ed2c076d9ce9e7a">i2c_command</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Raw I2C commands. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga0838ceb9488b3ce18ed2c076d9ce9e7aa0551f14633e9a4c957f5dab457ecd584"></a><!-- doxytag: member="i2c_cmd_send_start" ref="gga0838ceb9488b3ce18ed2c076d9ce9e7aa0551f14633e9a4c957f5dab457ecd584" args="" -->i2c_cmd_send_start</em>&nbsp;</td><td>
<p>Send START condition </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga0838ceb9488b3ce18ed2c076d9ce9e7aa031ee7043a4acea53c318e4c887fe954"></a><!-- doxytag: member="i2c_cmd_send_restart" ref="gga0838ceb9488b3ce18ed2c076d9ce9e7aa031ee7043a4acea53c318e4c887fe954" args="" -->i2c_cmd_send_restart</em>&nbsp;</td><td>
<p>Send RESTART condition </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga0838ceb9488b3ce18ed2c076d9ce9e7aa8802d6ff751df38d08a3085eb428261c"></a><!-- doxytag: member="i2c_cmd_send_stop" ref="gga0838ceb9488b3ce18ed2c076d9ce9e7aa8802d6ff751df38d08a3085eb428261c" args="" -->i2c_cmd_send_stop</em>&nbsp;</td><td>
<p>Send STOP condition </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga0838ceb9488b3ce18ed2c076d9ce9e7aa0997f08cce263c6be0702e893af14ae6"></a><!-- doxytag: member="i2c_cmd_wait_ack" ref="gga0838ceb9488b3ce18ed2c076d9ce9e7aa0997f08cce263c6be0702e893af14ae6" args="" -->i2c_cmd_wait_ack</em>&nbsp;</td><td>
<p>Wait for an ACK </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga0838ceb9488b3ce18ed2c076d9ce9e7aa0c213ffe918bfb73fe1e027944a81f9f"></a><!-- doxytag: member="i2c_cmd_send_ack" ref="gga0838ceb9488b3ce18ed2c076d9ce9e7aa0c213ffe918bfb73fe1e027944a81f9f" args="" -->i2c_cmd_send_ack</em>&nbsp;</td><td>
<p>Send an ACK </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga0838ceb9488b3ce18ed2c076d9ce9e7aaf9f8a3d1ef256a43b22393f586acfa91"></a><!-- doxytag: member="i2c_cmd_send_nack" ref="gga0838ceb9488b3ce18ed2c076d9ce9e7aaf9f8a3d1ef256a43b22393f586acfa91" args="" -->i2c_cmd_send_nack</em>&nbsp;</td><td>
<p>Send a NACK </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga0838ceb9488b3ce18ed2c076d9ce9e7aa6f19f2a89c6713dfe792695608381785"></a><!-- doxytag: member="i2c_cmd_tx_data" ref="gga0838ceb9488b3ce18ed2c076d9ce9e7aa6f19f2a89c6713dfe792695608381785" args="" -->i2c_cmd_tx_data</em>&nbsp;</td><td>
<p>Internal use only </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga0838ceb9488b3ce18ed2c076d9ce9e7aa9ef1cdea15f1857ba8589b963f352a22"></a><!-- doxytag: member="i2c_cmd_rx_data" ref="gga0838ceb9488b3ce18ed2c076d9ce9e7aa9ef1cdea15f1857ba8589b963f352a22" args="" -->i2c_cmd_rx_data</em>&nbsp;</td><td>
<p>Internal use only </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaf49bebc525106fe161824a3a093b4bf2"></a><!-- doxytag: member="i2c.h::I2cConfigClock" ref="gaf49bebc525106fe161824a3a093b4bf2" args="(uint8 scl_high, uint8 scl_low)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2cConfigClock </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"> <em>scl_high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"> <em>scl_low</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the high and low periods of the I2C clock. </p>
<p>The periods are given in 16th of a microsecond. When using a standard 100kHz or 400kHz period, the constants <a class="el" href="group__I2C.html#gae90ae7747a1e2c84124172845f063a61">I2C_SCL_100KBPS_HIGH_PERIOD</a>, <a class="el" href="group__I2C.html#ga57ef89c1e09ddf1ca71cf48761a0080b">I2C_SCL_100KBPS_LOW_PERIOD</a>, <a class="el" href="group__I2C.html#gaf3125dba4490c8743d9f80b7ce86a175">I2C_SCL_400KBPS_HIGH_PERIOD</a>, and <a class="el" href="group__I2C.html#gaf33b23cc933067b02e79ade1ab073485">I2C_SCL_400KBPS_LOW_PERIOD</a> can be used to supply the correct values.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">scl_high</td><td>High period of I2C clock </td></tr>
    <tr><td class="paramname">scl_low</td><td>Low period of I2C clock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa181563246248aaf6473629893f0876a"></a><!-- doxytag: member="i2c.h::I2cEepromRead" ref="gaa181563246248aaf6473629893f0876a" args="(uint16 device, uint16 address, bool wait, uint16 length, uint16 *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a> I2cEepromRead </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>wait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"> <em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read bytes from a standard I2C EEPROM. </p>
<p>The data read from the device is stored as packed data in the buffer pointed to by <code>data</code>. Despite storing packed data, the length must be the number of <b>bytes</b> to read. Therefore, if the length is odd the last word of the buffer will have an undefined value in the Most-Significant Byte (MSB).</p>
<p>The data is read from the EEPROM within one I2C transaction. Therefore the EEPROM must support Sequential Reads. It is also assumed that the EEPROM does not have any page size restrictions on the Sequential Read (i.e. if requested it can support reading the entire memory contents at once). If sequential reads are not supported, the application can use this function to read one byte at a time.</p>
<p>Non-blocking reads are supported. If the <code>wait</code> parameter is set to FALSE the function will return as soon as the I2C hardware has been configured to start receiving. The application can then use <a class="el" href="group__I2C.html#ga5d7ec5f88f785c09d1638e324f0b89b2">I2cReady()</a> to check if the read operation has completed, although it must also always call <a class="el" href="group__I2C.html#ga85dbb9d66d9207910e6017e15220830f">I2cEepromReadComplete()</a> to properly terminate the procedure within the driver.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The device address is a 7-bit value, and does not include the read/ write indicator bit.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>I2C device address </td></tr>
    <tr><td class="paramname">address</td><td>Address in EEPROM memory to start reading the data from </td></tr>
    <tr><td class="paramname">wait</td><td>Wait for read to complete if TRUE </td></tr>
    <tr><td class="paramname">length</td><td>The number of <b>bytes</b> to read </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to storage for the data that is read</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status of operation </dd></dl>

</div>
</div>
<a class="anchor" id="ga85dbb9d66d9207910e6017e15220830f"></a><!-- doxytag: member="i2c.h::I2cEepromReadComplete" ref="ga85dbb9d66d9207910e6017e15220830f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a> I2cEepromReadComplete </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finish writing bytes to the I2C bus. </p>
<p>This function must be called if the application previously started an I2C byte write using <a class="el" href="group__I2C.html#gaa181563246248aaf6473629893f0876a">I2cEepromRead()</a> but didn't wait for it to finish. An error will be returned if no read has been started. If the read operation has already completed then the function will return immediately, otherwise it will wait until the operation has completed and then return.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status of operation </dd></dl>

</div>
</div>
<a class="anchor" id="ga95d66c188ad80a22d138a181c0cdb5b7"></a><!-- doxytag: member="i2c.h::I2cEepromSetWriteCycleTime" ref="ga95d66c188ad80a22d138a181c0cdb5b7" args="(uint16 cycle_time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2cEepromSetWriteCycleTime </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>cycle_time</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the EEPROM write cycle time (in microseconds). </p>
<p>The write cycle time is the amount of time required by the I2C EEPROM after a STOP condition to complete the write activity. The default time is 5ms. </p>

</div>
</div>
<a class="anchor" id="ga45a16eb8525adef8635eede7249a6be5"></a><!-- doxytag: member="i2c.h::I2cEepromSetWritePageSize" ref="ga45a16eb8525adef8635eede7249a6be5" args="(uint16 page_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2cEepromSetWritePageSize </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>page_size</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the EEPROM page size for write operations. </p>
<p>The default page size is 128 bytes. An application only needs to call this function if it wishes to use an alternate page size. A page size of zero is not allowed / ignored. </p>

</div>
</div>
<a class="anchor" id="ga20dba0770393f239b60f789ea3b4f4f4"></a><!-- doxytag: member="i2c.h::I2cEepromWrite" ref="ga20dba0770393f239b60f789ea3b4f4f4" args="(uint16 device, uint16 address, bool wait, uint16 length, const uint16 *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a> I2cEepromWrite </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>wait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16 *&#160;</td>
          <td class="paramname"> <em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write bytes to a standard I2C EEPROM. </p>
<p>This function performs a complete I2C transaction, from START condition, sending the device address, writing the address in memory, writing the data bytes and generating a STOP condition.</p>
<p>The data to be written to the device should be passed to the function as packed data in the buffer pointed to by <code>data</code>. Despite being packed, the length must be the number of <b>bytes</b> to write. If the length is odd the last byte will be taken from the Least-Significant Byte (LSB) of the last word of the buffer.</p>
<p>The EEPROM Page Size parameter (see <a class="el" href="group__I2C.html#ga45a16eb8525adef8635eede7249a6be5">I2cEepromSetWritePageSize</a>) defines the maximum number of bytes that will be written to an EEPROM within one I2C transaction (START condition to STOP condition). After each transaction the driver will wait for Write Cycle Time (see <a class="el" href="group__I2C.html#ga95d66c188ad80a22d138a181c0cdb5b7">I2cEepromSetWriteCycleTime</a>) to elapse before it starts the next transaction or completes.</p>
<p>If the start address for the write does not lie on a page boundary or the data to be written crosses page boundaries, the driver will also ensure that write is broken down into multiple writes, with one write per page. For example, with a Page Size of 128, a write starting at address 100 for 40 bytes would result in two I2C transactions: the first writing 28 bytes from 100 - 127, and the second writing 12 bytes from 128 to 139.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The device address is a 7-bit value, and does not include the read/ write indicator bit.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The EEPROM Write procedure does not currently support non-blocking operation. However to ensure forward compatibility applications are recommended to always set the <code>wait</code> parameter to TRUE. This will mean that if a future release supports non-blocking writes that existing applications will continue to work as expected.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>I2C device address </td></tr>
    <tr><td class="paramname">address</td><td>Address in EEPROM memory to start writing the data to </td></tr>
    <tr><td class="paramname">wait</td><td>[Not currently used - application <b>must</b> set to <b>TRUE</b>] </td></tr>
    <tr><td class="paramname">length</td><td>The number of <b>bytes</b> to write </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the data to be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status of operation </dd></dl>

</div>
</div>
<a class="anchor" id="gabdf886596abe1dad7baf697143d17588"></a><!-- doxytag: member="i2c.h::I2cEnable" ref="gabdf886596abe1dad7baf697143d17588" args="(bool enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2cEnable </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>enable</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable or disable the I2C controller. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>TRUE to enable the controller or FALSE to disable it </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5bf91001b79485a43b0ef1bfee9d58a5"></a><!-- doxytag: member="i2c.h::I2cInit" ref="ga5bf91001b79485a43b0ef1bfee9d58a5" args="(uint8 sda_pio, uint8 scl_pio, uint8 power_pio, pio_pull_mode pull)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2cInit </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"> <em>sda_pio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"> <em>scl_pio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"> <em>power_pio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PIO__B.html#ga8e3150c3867c3218db866f0c1862074e">pio_pull_mode</a>&#160;</td>
          <td class="paramname"> <em>pull</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialise the I2C library. </p>
<p>Configure the PIOs required for I2C bus communication, with the CSR1000 operating as I2C Bus Master. The I2C bus can be assigned to any of the 32 general purpose PIO pins (PIO[31:0] or to the reserved I2C bus pins by specifying a PIO of <a class="el" href="group__I2C.html#ga699cee3c0b2cc2e8ab4dfb355179709b">I2C_RESERVED_PIO</a> for the <code>sda_pio</code> and <code>scl_pio</code> parameters. If the application selects PIO[31:16] (only available on a CSR1001 chip) while running on a CSR1000 chip no error will be returned, but of course the bus will not be externally available.</p>
<p>The <code>'power_pio'</code> parameter is used to assign an optional PIO to manage the power rail to the I2C device. If the I2C device is permanently powered, or if power is managed directly by the application, then this PIO value should be set to <a class="el" href="group__I2C.html#ga969d15be24cb0b1fe267f664820eab90">I2C_POWER_PIO_UNDEFINED</a> to disable it.</p>
<p>The <code>'pull'</code> parameter sets the default pulling mode for the I2C pins. The application can change the pulling mode at any time after calling I2cInit by calling <a class="el" href="group__PIO__B.html#ga85f7882e8a81037e8fa5ede0fe44f10b">PioSetPullModes()</a> for general PIOs or <a class="el" href="group__PIO__B.html#ga67517140cb6acc3c8faa0b872c77ebad">PioSetI2CPullMode()</a> for the reserved I2C pins. If the I2C bus is initialised to use general PIOs then the reserved I2C pins will have their pulling mode set to pio_i2c_pull_mode_no_pulls.</p>
<p>After calling this function all subsequent I2C operations will use the selected PIOs for communicating with the I2C peripheral.</p>
<p>Calling this function will reset the I2C clock configuration parameters so that devices are clocked at the standard rate of 100kHz.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sda_pio</td><td>PIO (0-31, 0xFF) to use for I2C Serial Data. </td></tr>
    <tr><td class="paramname">scl_pio</td><td>PIO (0-31, 0xFF) to use for I2C Serial Clock. </td></tr>
    <tr><td class="paramname">power_pio</td><td>PIO (0-31, 0xFF) to use for I2C power control </td></tr>
    <tr><td class="paramname">pull</td><td>The default PIO pull mode to use for the I2C bus. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa9fb17504925ce9198259b8e557ef67d"></a><!-- doxytag: member="i2c.h::I2cRawCommand" ref="gaa9fb17504925ce9198259b8e557ef67d" args="(i2c_command cmd, bool wait, uint16 timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a> I2cRawCommand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__I2C.html#ga0838ceb9488b3ce18ed2c076d9ce9e7a">i2c_command</a>&#160;</td>
          <td class="paramname"> <em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>wait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send a raw I2C command to I2C controller. </p>
<p>This function is used to generate single I2C events on the bus. This allows the application to communicate with I2C devices other than standard EEPROMs.</p>
<p>The device driver can optionally either wait for the command to complete, or can return immediately, with the command pending. If the command is left pending then the application should call <a class="el" href="group__I2C.html#ga23925a0f653ed9905a2872c98f34443d" title="Wait for the last issued I2C command to complete.">I2cRawComplete()</a> later on to complete and return the status of the command.</p>
<p>There are also a number of helper macros defined to make it simpler to generate the various I2C commands, using default timeout periods. These macros may be more obvious to use than directly calling I2cRawCommand.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>If the application requests a <a class="el" href="group__I2C.html#gga0838ceb9488b3ce18ed2c076d9ce9e7aa0997f08cce263c6be0702e893af14ae6">i2c_cmd_wait_ack</a> command but no ACK is received within the timeout period then the I2C transaction will have completed. The application must either then terminate the raw command sequence with <a class="el" href="group__I2C.html#ga0955f7ed53902b8ba8e09b13a2500af5" title="Ends the sequence of I2C raw commands.">I2cRawTerminate()</a> or start a new sequence with <a class="el" href="group__I2C.html#ga5112ec824d21b94e7d06517a7b2d754a">I2cRawStart()</a>.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>The command to send </td></tr>
    <tr><td class="paramname">wait</td><td>TRUE if the function should wait for the transaction to complete </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout period (in microseconds) to wait for the transaction to complete</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status of operation </dd></dl>

</div>
</div>
<a class="anchor" id="ga23925a0f653ed9905a2872c98f34443d"></a><!-- doxytag: member="i2c.h::I2cRawComplete" ref="ga23925a0f653ed9905a2872c98f34443d" args="(uint16 timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a> I2cRawComplete </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>timeout</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for the last issued I2C command to complete. </p>
<p>If the command completes within the timeout period, then the controller status will be returned, otherwise <a class="el" href="group__STAT.html#gga4d0e4416aa801fbed0a19d3d24fdbba6acaa7148cc1985e21d7b012ecc5d754ee">i2c_status_fail_timeout</a> will be returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Timeout period (in microseconds) to wait for the transaction to complete</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status of operation </dd></dl>

</div>
</div>
<a class="anchor" id="ga87a181186f86c3dfbdd3bc999e74a814"></a><!-- doxytag: member="i2c.h::I2cRawRead" ref="ga87a181186f86c3dfbdd3bc999e74a814" args="(uint8 *data, uint16 length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a> I2cRawRead </td>
          <td>(</td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read data from the I2C bus, ACKing received bytes and NACKing the last byte. </p>
<p>This command assumes the I2C slave device has been put into a state where it is ready to transmit bytes. The function will block until the read operation has completed, and all bytes have been read.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to storage for the bytes that are read. </td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status of operation </dd></dl>

</div>
</div>
<a class="anchor" id="ga2cefeecf965f91fb1373d03e4cbb6f46"></a><!-- doxytag: member="i2c.h::I2cRawReadByte" ref="ga2cefeecf965f91fb1373d03e4cbb6f46" args="(uint8 *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a> I2cRawReadByte </td>
          <td>(</td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"> <em>data</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a byte of data from the I2C bus. </p>
<p>This command assumes the I2C slave device has been put into a state where it is ready to transmit a byte. The function will block until the read operation has completed.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This function does NOT generate the I2C ACK/NACK condition after reading the byte. If the application needs to read one or more bytes and generate standard ACK/NACK conditions after each byte then <a class="el" href="group__I2C.html#ga87a181186f86c3dfbdd3bc999e74a814">I2cRawRead()</a> may be more suitable.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to storage for the byte that is read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status of operation </dd></dl>

</div>
</div>
<a class="anchor" id="ga0955f7ed53902b8ba8e09b13a2500af5"></a><!-- doxytag: member="i2c.h::I2cRawTerminate" ref="ga0955f7ed53902b8ba8e09b13a2500af5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a> I2cRawTerminate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ends the sequence of I2C raw commands. </p>
<p>If an application uses both raw commands and the atomic read/write functions to access an I2C device it must properly terminate the raw command sequence by calling this function before it can use the byte read/write functions again. This is to ensure that the device is in a known state for the read/write functions.</p>
<p>This function only updates internal driver state - it does not generate any further transactions on the I2C bus. Therefore the application must ensure that it properly completes a raw command sequence with an I2C STOP condition before calling this function.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status of operation </dd></dl>

</div>
</div>
<a class="anchor" id="gac84164887f158a64c866d0828e04bb7c"></a><!-- doxytag: member="i2c.h::I2cRawWrite" ref="gac84164887f158a64c866d0828e04bb7c" args="(const uint8 *data, uint16 length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a> I2cRawWrite </td>
          <td>(</td>
          <td class="paramtype">const uint8 *&#160;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write data to the I2C bus, waiting for ACK after each byte. </p>
<p>This command assumes the I2C slave device has been put into a state where it is ready to receive bytes. The function will block until the write operation has completed, and all bytes have been transmitted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to the bytes that are to be written. </td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status of operation </dd></dl>

</div>
</div>
<a class="anchor" id="ga5eebec1901354d7206f9f98ec04285b0"></a><!-- doxytag: member="i2c.h::I2cRawWriteByte" ref="ga5eebec1901354d7206f9f98ec04285b0" args="(uint8 data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a> I2cRawWriteByte </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"> <em>data</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a byte of data to the I2C bus. </p>
<p>This command assumes the I2C slave device has been put into a state where it is ready to receive a byte. The function will block until the write operation has completed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The byte that is to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status of operation </dd></dl>

</div>
</div>
<a class="anchor" id="ga5d7ec5f88f785c09d1638e324f0b89b2"></a><!-- doxytag: member="i2c.h::I2cReady" ref="ga5d7ec5f88f785c09d1638e324f0b89b2" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool I2cReady </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test to see if the current I2C transaction has completed. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if I2C transaction has completed or FALSE if it is ongoing. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4fda2ce4cde1367d286aeba7f2648837"></a><!-- doxytag: member="i2c.h::I2cReset" ref="ga4fda2ce4cde1367d286aeba7f2648837" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a> I2cReset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset the I2C controller. </p>
<p>Resets the I2C controller without waiting for any current read or write commands to finish. This is advised only as part of the initialisation procedure, or to recover from an incorrect state in the I2C controller.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status of operation </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Jun 22 2016 11:39:14 for CSR ÂµEnergy&reg; Firmware by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
