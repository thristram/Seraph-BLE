<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CSR µEnergy&reg; Firmware: Power Management</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Power Management<br/>
<small>
[<a class="el" href="group__SYS.html">System</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PWRMGMT.html#ga0e9693b0d29967f608c51115dc40b2e2">sleep_state</a> { <br/>
&#160;&#160;<a class="el" href="group__PWRMGMT.html#gga0e9693b0d29967f608c51115dc40b2e2a57790fbd9bf50786e606e124bcec1038">sleep_state_cold_powerup</a>, 
<a class="el" href="group__PWRMGMT.html#gga0e9693b0d29967f608c51115dc40b2e2a1f89f5e5842aac81921d85e41c939637">sleep_state_warm_powerup</a>, 
<a class="el" href="group__PWRMGMT.html#gga0e9693b0d29967f608c51115dc40b2e2aa01926a7626d54b73d6b6d2ad7bff0d7">sleep_state_dormant</a>, 
<a class="el" href="group__PWRMGMT.html#gga0e9693b0d29967f608c51115dc40b2e2a4a3f35248c0e7c26f775d062f754cbfd">sleep_state_hibernate</a>, 
<br/>
&#160;&#160;<a class="el" href="group__PWRMGMT.html#gga0e9693b0d29967f608c51115dc40b2e2a34a7e8d7821d7c9622c87db17cba0fc5">sleep_state_warm_reset</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The state the chip woke up from. </p>
 <a href="group__PWRMGMT.html#ga0e9693b0d29967f608c51115dc40b2e2">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PWRMGMT.html#gaa45550efd9b010a54cf9bd23baef456c">sleep_mode</a> { <a class="el" href="group__PWRMGMT.html#ggaa45550efd9b010a54cf9bd23baef456caddb8f6137882561103be5ed3dcab5fe9">sleep_mode_never</a>, 
<a class="el" href="group__PWRMGMT.html#ggaa45550efd9b010a54cf9bd23baef456ca7faaf24da33881117e6ce7315999f088">sleep_mode_deep</a>, 
<a class="el" href="group__PWRMGMT.html#ggaa45550efd9b010a54cf9bd23baef456cac21e55fb059852ce96e2cad2041f1fa8">sleep_mode_shallow</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The power state used by the chip when the radio is idle. </p>
 <a href="group__PWRMGMT.html#gaa45550efd9b010a54cf9bd23baef456c">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PWRMGMT.html#gaf861ad612fa82eba726fd387dc5243c7">wakepin_mode</a> { <a class="el" href="group__PWRMGMT.html#ggaf861ad612fa82eba726fd387dc5243c7aa35db941a853ce5d216c44ecf3846eef">wakepin_mode_disable</a>, 
<a class="el" href="group__PWRMGMT.html#ggaf861ad612fa82eba726fd387dc5243c7aa71299256759cdae33a3c2fb8ce929d3">wakepin_mode_low_level</a>, 
<a class="el" href="group__PWRMGMT.html#ggaf861ad612fa82eba726fd387dc5243c7a752b5b67c6b30daff7fa7c3ba5861331">wakepin_mode_high_level</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The WAKE pin mode controls which edges the CSR100x/CSR101x will wake on (if required). </p>
 <a href="group__PWRMGMT.html#gaf861ad612fa82eba726fd387dc5243c7">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PWRMGMT.html#gaf85807913e5e35c1f3ae1ca4f07c9a0c">SleepModeChange</a> (<a class="el" href="group__PWRMGMT.html#gaa45550efd9b010a54cf9bd23baef456c">sleep_mode</a> new_mode)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell the firmware to use a particular sleep mode for all subsequent periods when it is able to sleep.  <a href="#gaf85807913e5e35c1f3ae1ca4f07c9a0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PWRMGMT.html#gabd0e44698d0ece855ad050d7f64a3a5b">SleepRequest</a> (<a class="el" href="group__PWRMGMT.html#ga0e9693b0d29967f608c51115dc40b2e2">sleep_state</a> new_sleep_state, bool wake_active_high, <a class="el" href="group__TIME.html#ga18ca68e4f93d6326ff1580383acae688">time48</a> hibernate_duration)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a transition to one of the sleep states Hibernate or Dormant, as specified by new_sleep_state.  <a href="#gabd0e44698d0ece855ad050d7f64a3a5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PWRMGMT.html#gac44ea90187c6dae1adeb6ff20f3f36cc">SleepWakePinEnable</a> (<a class="el" href="group__PWRMGMT.html#gaf861ad612fa82eba726fd387dc5243c7">wakepin_mode</a> mode)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the operating mode of the WAKE pin.  <a href="#gac44ea90187c6dae1adeb6ff20f3f36cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PWRMGMT.html#ga81c50443a0a930fb3b0961168bfc8f3d">SleepWakePinStatus</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current state of the WAKE pin.  <a href="#ga81c50443a0a930fb3b0961168bfc8f3d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PWRMGMT.html#ga7a75a9a70ec1d0831ee3cefbd4db1c7a">SleepWakeOnUartRX</a> (bool enable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wake from Deep Sleep if the UART sees incoming data. On enabling the UART, the default is to wake on incoming data. This function may only be called when the UART is enabled either via <a class="el" href="group__DBG.html#ga8f0ddc73d6b7f1571f80cecd60a0771c">DebugInit</a> or <a class="el" href="group__UART.html#ga3e234bb70dd8df6deb9ad2bdbb1ba538">UartEnable</a>.  <a href="#ga7a75a9a70ec1d0831ee3cefbd4db1c7a"></a><br/></td></tr>
</table>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="gaa45550efd9b010a54cf9bd23baef456c"></a><!-- doxytag: member="sleep.h::sleep_mode" ref="gaa45550efd9b010a54cf9bd23baef456c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__PWRMGMT.html#gaa45550efd9b010a54cf9bd23baef456c">sleep_mode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The power state used by the chip when the radio is idle. </p>
<p>These are the values that can be written to the sleep_mode Configuration Store key, and also requested by the application using the <a class="el" href="group__PWRMGMT.html#gaf85807913e5e35c1f3ae1ca4f07c9a0c" title="Tell the firmware to use a particular sleep mode for all subsequent periods when it is able to sleep...">SleepModeChange()</a> API call.</p>
<p>Three sleep modes are supported: Deep Sleep; Shallow Sleep; Always Awake</p>
<p>Deep Sleep is the most useful, and ensures that the chip is using the 32kHz clock when the application, firmware, and radio are idle. The firmware will automatically handle the transition between the Deep Sleep and Awake states subject to system events (e.g. radio activity, expiry of timers, external interrupt sources, etc.)</p>
<p>Shallow Sleep is useful in certain application that want to use the main processor or the 8051 PIO Controller to perform high-speed or low-latency I/O. In this mode, the chip remains running off the 16MHz clock at all times therefore there is little latency when the chip needs to wake up. However this mode will increase the overall current consumption quite considerably. Whilst in Shallow Sleep the internal Power Supply will run in an optimised state, in order to reduce its current consumption, at any time the radio is not in use. As with Deep Sleep, in this state the firmware will manage the power supply settings subject to system events.</p>
<p>Always Awake is of limited use. The chip remains running off the 16MHz clock and the internal power supply runs in its normal "awake" state where it is capable of supplying full power to the radio, even if the radio is not in use.</p>
<p>There are two methods of controlling the sleep mode used by the firmware. The first is to set the sleep_mode CS key. The value set in this key will be used by the firmware from power-up until (and if) the application requests an alternate mode by calling the <a class="el" href="group__PWRMGMT.html#gaf85807913e5e35c1f3ae1ca4f07c9a0c" title="Tell the firmware to use a particular sleep mode for all subsequent periods when it is able to sleep...">SleepModeChange()</a> API. If the application does not need to change the selected sleep mode at runtime then it is sufficient to just set the CS key. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggaa45550efd9b010a54cf9bd23baef456caddb8f6137882561103be5ed3dcab5fe9"></a><!-- doxytag: member="sleep_mode_never" ref="ggaa45550efd9b010a54cf9bd23baef456caddb8f6137882561103be5ed3dcab5fe9" args="" -->sleep_mode_never</em>&nbsp;</td><td>
<p>Always Awake </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa45550efd9b010a54cf9bd23baef456ca7faaf24da33881117e6ce7315999f088"></a><!-- doxytag: member="sleep_mode_deep" ref="ggaa45550efd9b010a54cf9bd23baef456ca7faaf24da33881117e6ce7315999f088" args="" -->sleep_mode_deep</em>&nbsp;</td><td>
<p>Deep Sleep </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa45550efd9b010a54cf9bd23baef456cac21e55fb059852ce96e2cad2041f1fa8"></a><!-- doxytag: member="sleep_mode_shallow" ref="ggaa45550efd9b010a54cf9bd23baef456cac21e55fb059852ce96e2cad2041f1fa8" args="" -->sleep_mode_shallow</em>&nbsp;</td><td>
<p>Shallow Sleep </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0e9693b0d29967f608c51115dc40b2e2"></a><!-- doxytag: member="sleep.h::sleep_state" ref="ga0e9693b0d29967f608c51115dc40b2e2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__PWRMGMT.html#ga0e9693b0d29967f608c51115dc40b2e2">sleep_state</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The state the chip woke up from. </p>
<p>If the application requests Hibernate or Dormant, and the power is subsequently removed, the sleep state recorded on the next wake event will be dependent on how long power was lost for (i.e. whether or not the data in the persistent memory was still valid). </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga0e9693b0d29967f608c51115dc40b2e2a57790fbd9bf50786e606e124bcec1038"></a><!-- doxytag: member="sleep_state_cold_powerup" ref="gga0e9693b0d29967f608c51115dc40b2e2a57790fbd9bf50786e606e124bcec1038" args="" -->sleep_state_cold_powerup</em>&nbsp;</td><td>
<p>The device powered up after a long time without power </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga0e9693b0d29967f608c51115dc40b2e2a1f89f5e5842aac81921d85e41c939637"></a><!-- doxytag: member="sleep_state_warm_powerup" ref="gga0e9693b0d29967f608c51115dc40b2e2a1f89f5e5842aac81921d85e41c939637" args="" -->sleep_state_warm_powerup</em>&nbsp;</td><td>
<p>The device powered up after a short time without power (less than ~1 minute, based on how long data remains valid in the persistent memory) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga0e9693b0d29967f608c51115dc40b2e2aa01926a7626d54b73d6b6d2ad7bff0d7"></a><!-- doxytag: member="sleep_state_dormant" ref="gga0e9693b0d29967f608c51115dc40b2e2aa01926a7626d54b73d6b6d2ad7bff0d7" args="" -->sleep_state_dormant</em>&nbsp;</td><td>
<p>The device powered up after being placed into the Dormant state </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga0e9693b0d29967f608c51115dc40b2e2a4a3f35248c0e7c26f775d062f754cbfd"></a><!-- doxytag: member="sleep_state_hibernate" ref="gga0e9693b0d29967f608c51115dc40b2e2a4a3f35248c0e7c26f775d062f754cbfd" args="" -->sleep_state_hibernate</em>&nbsp;</td><td>
<p>The device powered up after being placed into the Hibernate state </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga0e9693b0d29967f608c51115dc40b2e2a34a7e8d7821d7c9622c87db17cba0fc5"></a><!-- doxytag: member="sleep_state_warm_reset" ref="gga0e9693b0d29967f608c51115dc40b2e2a34a7e8d7821d7c9622c87db17cba0fc5" args="" -->sleep_state_warm_reset</em>&nbsp;</td><td>
<p>The device powered up after an application-triggered warm reset </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf861ad612fa82eba726fd387dc5243c7"></a><!-- doxytag: member="sleep.h::wakepin_mode" ref="gaf861ad612fa82eba726fd387dc5243c7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__PWRMGMT.html#gaf861ad612fa82eba726fd387dc5243c7">wakepin_mode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The WAKE pin mode controls which edges the CSR100x/CSR101x will wake on (if required). </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggaf861ad612fa82eba726fd387dc5243c7aa35db941a853ce5d216c44ecf3846eef"></a><!-- doxytag: member="wakepin_mode_disable" ref="ggaf861ad612fa82eba726fd387dc5243c7aa35db941a853ce5d216c44ecf3846eef" args="" -->wakepin_mode_disable</em>&nbsp;</td><td>
<p>Disable the WAKE pin </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaf861ad612fa82eba726fd387dc5243c7aa71299256759cdae33a3c2fb8ce929d3"></a><!-- doxytag: member="wakepin_mode_low_level" ref="ggaf861ad612fa82eba726fd387dc5243c7aa71299256759cdae33a3c2fb8ce929d3" args="" -->wakepin_mode_low_level</em>&nbsp;</td><td>
<p>Pulling the WAKE pin low keeps the CSR100x/CSR101x awake </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaf861ad612fa82eba726fd387dc5243c7a752b5b67c6b30daff7fa7c3ba5861331"></a><!-- doxytag: member="wakepin_mode_high_level" ref="ggaf861ad612fa82eba726fd387dc5243c7a752b5b67c6b30daff7fa7c3ba5861331" args="" -->wakepin_mode_high_level</em>&nbsp;</td><td>
<p>Pulling the WAKE pin high keeps the CSR100x/CSR101x awake </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaf85807913e5e35c1f3ae1ca4f07c9a0c"></a><!-- doxytag: member="sleep.h::SleepModeChange" ref="gaf85807913e5e35c1f3ae1ca4f07c9a0c" args="(sleep_mode new_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SleepModeChange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PWRMGMT.html#gaa45550efd9b010a54cf9bd23baef456c">sleep_mode</a>&#160;</td>
          <td class="paramname"> <em>new_mode</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tell the firmware to use a particular sleep mode for all subsequent periods when it is able to sleep. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">new_mode</td><td>The new sleep mode to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing. </dd></dl>

</div>
</div>
<a class="anchor" id="gabd0e44698d0ece855ad050d7f64a3a5b"></a><!-- doxytag: member="sleep.h::SleepRequest" ref="gabd0e44698d0ece855ad050d7f64a3a5b" args="(sleep_state new_sleep_state, bool wake_active_high, time48 hibernate_duration)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SleepRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PWRMGMT.html#ga0e9693b0d29967f608c51115dc40b2e2">sleep_state</a>&#160;</td>
          <td class="paramname"> <em>new_sleep_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>wake_active_high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TIME.html#ga18ca68e4f93d6326ff1580383acae688">time48</a>&#160;</td>
          <td class="paramname"> <em>hibernate_duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request a transition to one of the sleep states Hibernate or Dormant, as specified by new_sleep_state. </p>
<p>Hibernate and Dormant states can be requested irrespective of the currently selected sleep mode (i.e. they are allowed even if the sleep mode is set to sleep_mode_never).</p>
<p>The wakeup condition is specified by the wake_active_high parameter. Set this to TRUE if the chip should wake when the WAKE pin is at logic level 1, or set to FALSE if the chip should wake at logic level 0. NOTE: The CSR100x/CSR101x does not have an internal pull-up or pull-down resistor on the WAKE pin therefore an external resistor should be used.</p>
<p>When requesting Hibernate, a non-zero duration must be provided. This will be added onto the current system time to calculate the next wakeup time. The device will automatically wake up after the time has passed, or sooner if there is an external wake event on the dedicated WAKE pin. hibernate_duration is expressed in microseconds. However, the minimum allowed duration is 2^20 microseconds (1.048576s). In practise most real-world applications will actually require a much longer duration in order to realise any additional power-savings over Deep Sleep mode. The firmware will raise a fault and panic if the duration is too small.</p>
<p>The requested hibernate_duration is a suggested minimum. The system will sleep for at least that time, unless there is an external WAKE event, but it will always be slightly longer until the chip has completely woken up, due to system startup time. The exact time from an application requesting Hibernate until it gets called again at wakeup cannot be guaranteed.</p>
<p>The hibernate_duration is ignored if the application requests Dormant. In this state the device will *only* wake up if there is an external event on the WAKE pin.</p>
<p>WARNING! This function will *NOT* return. The device will go to a low power state and will perform a full RAM reset when it wakes up again. Any information that you need to save must be stored in the persistent memory before requesting the low power state.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">new_sleep_state</td><td>The requested sleep state (Hibernate or Dormant) </td></tr>
    <tr><td class="paramname">wake_active_high</td><td>WAKE pin polarity (acitve high or active low) </td></tr>
    <tr><td class="paramname">hibernate_duration</td><td>Time (in microseconds) to hibernate for </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NEVER RETURNS! </dd></dl>

</div>
</div>
<a class="anchor" id="ga7a75a9a70ec1d0831ee3cefbd4db1c7a"></a><!-- doxytag: member="sleep.h::SleepWakeOnUartRX" ref="ga7a75a9a70ec1d0831ee3cefbd4db1c7a" args="(bool enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SleepWakeOnUartRX </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>enable</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wake from Deep Sleep if the UART sees incoming data. On enabling the UART, the default is to wake on incoming data. This function may only be called when the UART is enabled either via <a class="el" href="group__DBG.html#ga8f0ddc73d6b7f1571f80cecd60a0771c">DebugInit</a> or <a class="el" href="group__UART.html#ga3e234bb70dd8df6deb9ad2bdbb1ba538">UartEnable</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>TRUE to wake from Deep Sleep on UART RX, FALSE to remain asleep </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing. </dd></dl>

</div>
</div>
<a class="anchor" id="gac44ea90187c6dae1adeb6ff20f3f36cc"></a><!-- doxytag: member="sleep.h::SleepWakePinEnable" ref="gac44ea90187c6dae1adeb6ff20f3f36cc" args="(wakepin_mode mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SleepWakePinEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PWRMGMT.html#gaf861ad612fa82eba726fd387dc5243c7">wakepin_mode</a>&#160;</td>
          <td class="paramname"> <em>mode</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the operating mode of the WAKE pin. </p>
<p>Allows the user application to configure the operating mode of the chip's WAKE pin.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>The new WAKE pin mode to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing. </dd></dl>

</div>
</div>
<a class="anchor" id="ga81c50443a0a930fb3b0961168bfc8f3d"></a><!-- doxytag: member="sleep.h::SleepWakePinStatus" ref="ga81c50443a0a930fb3b0961168bfc8f3d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SleepWakePinStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the current state of the WAKE pin. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if WAKE pin is high else FALSE. </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Jun 22 2016 11:39:14 for CSR µEnergy&reg; Firmware by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
