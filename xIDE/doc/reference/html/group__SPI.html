<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CSR ÂµEnergy&reg; Firmware: SPI Serial Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#enumval-members">Enumerator</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>SPI Serial Interface<br/>
<small>
[<a class="el" href="group__SERIF.html">Serial Interfaces</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>The SPI library functions provide access to SPI devices attached to a group of PIOs. The CSR1000 acts as SPI Master using SPI Mode 3 operation.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#ga6a72cd674aaf77593f0383220219b1c4">SPI_NCS_PIO_UNDEFINED</a>&#160;&#160;&#160;0xff</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">PIO selection to be used if the application wants to control the SPI chip select line(s) instead of the firmware.  <a href="#ga6a72cd674aaf77593f0383220219b1c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#ga92420f1ab1fe6b710f783edc7d63fed7">SPI_FLASH_DEFAULT_PIO</a>&#160;&#160;&#160;0xFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default PIO should be used for SPI Flash power or chip select signal.  <a href="#ga92420f1ab1fe6b710f783edc7d63fed7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#ga3e9509438786fee97ebf9b2b158c045e">SPI_FLASH_POWER_PIO_UNDEFINED</a>&#160;&#160;&#160;0xFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">PIO value indicating that the SPI Flash device driver should not manage the power for the SPI Flash device.  <a href="#ga3e9509438786fee97ebf9b2b158c045e"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#ga053f5a2994fa79d9817609c75d5049aa">spi_erase_size</a> { <a class="el" href="group__SPI.html#gga053f5a2994fa79d9817609c75d5049aaa74ecc3d81b5121f226052c9662ea491a">spi_erase_4KB</a>, 
<a class="el" href="group__SPI.html#gga053f5a2994fa79d9817609c75d5049aaa382aa53065b073e21fd08f098d3d1685">spi_erase_32KB</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>SPI Flash block erase sizes. </p>
 <a href="group__SPI.html#ga053f5a2994fa79d9817609c75d5049aa">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#ga161ff18d77ad85f32b915ffbaf02264b">SpiInit</a> (uint16 mosi_pio, uint16 miso_pio, uint16 clk_pio, uint16 ncs_pio)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the SPI library.  <a href="#ga161ff18d77ad85f32b915ffbaf02264b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#ga25558cad981aeb123f8a56de322f1930">SpiConfigReadRegisterDelay</a> (uint16 delay)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Read Register Delay configuration parameter.  <a href="#ga25558cad981aeb123f8a56de322f1930"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#ga713744d5c968380d0cd6068f4638298c">SpiConfigWriteTerminationDelay</a> (uint16 delay)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Write Termination Delay configuration parameter.  <a href="#ga713744d5c968380d0cd6068f4638298c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#ga7a6d21f7a23de727d68d755a6046c559">SpiConfigWriteIntervalDelay</a> (uint16 delay)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Write Interval Delay configuration parameter.  <a href="#ga7a6d21f7a23de727d68d755a6046c559"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#ga9c509dc2a5c998a6c3556d1c54ab3f06">SpiWriteByte</a> (uint8 byte)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write one byte of data to a SPI peripheral device.  <a href="#ga9c509dc2a5c998a6c3556d1c54ab3f06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#ga1141e72a5264210e0999e9b4c11e186d">SpiWrite</a> (const uint8 *out_buffer, uint16 length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a sequence of bytes of data to a SPI peripheral device.  <a href="#ga1141e72a5264210e0999e9b4c11e186d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#gaccc9b929868870a6bd2a498a7f8dbdce">SpiWriteRegister</a> (uint8 reg_address, uint8 reg_value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to a register on a SPI peripheral device.  <a href="#gaccc9b929868870a6bd2a498a7f8dbdce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#ga498d7d3626d0229955ff3dcf1ec5a6c8">SpiReadByte</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one byte of data from a SPI peripheral device.  <a href="#ga498d7d3626d0229955ff3dcf1ec5a6c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#ga2c087dfb5aeb88adc70e0b3669e76f6b">SpiRead</a> (uint8 *in_buffer, uint16 length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a sequence of bytes of data from a SPI peripheral device and copy the data into the supplied buffer.  <a href="#ga2c087dfb5aeb88adc70e0b3669e76f6b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#ga6bbb9774772d33ceb8b1a02412ad5131">SpiReadRegister</a> (uint8 reg_address)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from a register on a SPI peripheral device.  <a href="#ga6bbb9774772d33ceb8b1a02412ad5131"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#ga27a763c150d7f8bce817c45d8a7539c9">SpiReadRegisterBurst</a> (uint8 reg_address, uint8 *in_buffer, uint16 length, bool toggle_clk)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Burst read multiple registers on a SPI peripheral device.  <a href="#ga27a763c150d7f8bce817c45d8a7539c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#ga7ef899a7e0bb261d7c0bddef1a82327a">SpiFlashInit</a> (uint16 ncs_pio, uint16 power_pio)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the SPI Flash library.  <a href="#ga7ef899a7e0bb261d7c0bddef1a82327a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8cda5aa8fde7f6063ecd58b9d760541d"></a><!-- doxytag: member="SPI::SpiFlashDisable" ref="ga8cda5aa8fde7f6063ecd58b9d760541d" args="(void)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#ga8cda5aa8fde7f6063ecd58b9d760541d">SpiFlashDisable</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable &amp; power-down the selected SPI Flash device. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#gad2501aed56a2e4c3d59c8f6b02c3081e">SpiFlashRead</a> (uint16 address, uint16 length, uint16 *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the selected SPI Flash device.  <a href="#gad2501aed56a2e4c3d59c8f6b02c3081e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#ga39d8d965b9920e98f68aeebe4b362439">SpiFlashWrite</a> (uint16 address, uint16 length, const uint16 *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to the selected SPI Flash device.  <a href="#ga39d8d965b9920e98f68aeebe4b362439"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#ga25460907c92c934ef3d69bf17cf7b55e">SpiFlashEraseBlock</a> (<a class="el" href="group__SPI.html#ga053f5a2994fa79d9817609c75d5049aa">spi_erase_size</a> size, uint16 address, bool wait)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a single block of the SPI Flash memory device.  <a href="#ga25460907c92c934ef3d69bf17cf7b55e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SPI.html#gaefcd3a272c32c20f8379be625e714249">SpiFlashEraseWaitComplete</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for an erase operation to complete.  <a href="#gaefcd3a272c32c20f8379be625e714249"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The SPI library functions provide access to SPI devices attached to a group of PIOs. The CSR1000 acts as SPI Master using SPI Mode 3 operation. </p>
<p>The SPI Flash library functions provide access to read, write, and erase SPI Flash devices attached to the same SPI bus as the CSR1000 boot device. The CSR1000 acts as SPI Master using SPI Mode 0 operation. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga92420f1ab1fe6b710f783edc7d63fed7"></a><!-- doxytag: member="spi_flash.h::SPI_FLASH_DEFAULT_PIO" ref="ga92420f1ab1fe6b710f783edc7d63fed7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPI_FLASH_DEFAULT_PIO&#160;&#160;&#160;0xFF</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default PIO should be used for SPI Flash power or chip select signal. </p>
<p>This constant can be used when calling <a class="el" href="group__SPI.html#ga7ef899a7e0bb261d7c0bddef1a82327a">SpiFlashInit()</a> if the application wants to use the default PIO for the power or chip select signals. For example, a design with two SPI Flash devices may use the same PIO for the boot device and the secondary device (to save a PIO) and use discrete chip select signals for each device. </p>

</div>
</div>
<a class="anchor" id="ga3e9509438786fee97ebf9b2b158c045e"></a><!-- doxytag: member="spi_flash.h::SPI_FLASH_POWER_PIO_UNDEFINED" ref="ga3e9509438786fee97ebf9b2b158c045e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPI_FLASH_POWER_PIO_UNDEFINED&#160;&#160;&#160;0xFF</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>PIO value indicating that the SPI Flash device driver should not manage the power for the SPI Flash device. </p>
<p>This constant can be used when calling <a class="el" href="group__SPI.html#ga7ef899a7e0bb261d7c0bddef1a82327a">SpiFlashInit()</a>. </p>

</div>
</div>
<a class="anchor" id="ga6a72cd674aaf77593f0383220219b1c4"></a><!-- doxytag: member="spi.h::SPI_NCS_PIO_UNDEFINED" ref="ga6a72cd674aaf77593f0383220219b1c4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPI_NCS_PIO_UNDEFINED&#160;&#160;&#160;0xff</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>PIO selection to be used if the application wants to control the SPI chip select line(s) instead of the firmware. </p>
<p>This constant can be used when calling <a class="el" href="group__SPI.html#ga161ff18d77ad85f32b915ffbaf02264b">SpiInit()</a>. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga053f5a2994fa79d9817609c75d5049aa"></a><!-- doxytag: member="spi_flash.h::spi_erase_size" ref="ga053f5a2994fa79d9817609c75d5049aa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__SPI.html#ga053f5a2994fa79d9817609c75d5049aa">spi_erase_size</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>SPI Flash block erase sizes. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga053f5a2994fa79d9817609c75d5049aaa74ecc3d81b5121f226052c9662ea491a"></a><!-- doxytag: member="spi_erase_4KB" ref="gga053f5a2994fa79d9817609c75d5049aaa74ecc3d81b5121f226052c9662ea491a" args="" -->spi_erase_4KB</em>&nbsp;</td><td>
<p>Erase a 4KB block </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga053f5a2994fa79d9817609c75d5049aaa382aa53065b073e21fd08f098d3d1685"></a><!-- doxytag: member="spi_erase_32KB" ref="gga053f5a2994fa79d9817609c75d5049aaa382aa53065b073e21fd08f098d3d1685" args="" -->spi_erase_32KB</em>&nbsp;</td><td>
<p>Erase a 32KB block </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga25558cad981aeb123f8a56de322f1930"></a><!-- doxytag: member="spi.h::SpiConfigReadRegisterDelay" ref="ga25558cad981aeb123f8a56de322f1930" args="(uint16 delay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpiConfigReadRegisterDelay </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>delay</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the Read Register Delay configuration parameter. </p>
<p>The Read Register Delay is the minimum period in microseconds that the SPI driver will wait between the rising edge of SCLK for the last bit of the register address byte to the falling edge of SCLK for the first bit of data read. The driver has internal delays that account for about 3.5us, so if a SPI slave needs more time than that to prepare a response, the app should set this delay to a non-zero value.</p>
<p>This value is only applied between writing the register address and reading the value(s) (including burst register reads). Burst Reads do no insert any additional delays between reading of individual register values.</p>
<p>The delay parameter is reset to 0 each time <a class="el" href="group__SPI.html#ga161ff18d77ad85f32b915ffbaf02264b">SpiInit()</a> is called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">delay</td><td>Extra delay (in microseconds). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7a6d21f7a23de727d68d755a6046c559"></a><!-- doxytag: member="spi.h::SpiConfigWriteIntervalDelay" ref="ga7a6d21f7a23de727d68d755a6046c559" args="(uint16 delay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpiConfigWriteIntervalDelay </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>delay</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the Write Interval Delay configuration parameter. </p>
<p>The Write Interval Delay is the minimum period in microseconds between subsequent byte transfers under SpiWrite. Some devices may require a long period to allow the data to be processed before the next byte.</p>
<p>With no delays specified the SPI driver code has an approximate delay of 5us due to internal processing, although this is not guaranteed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">delay</td><td>Extra delay (in microseconds). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga713744d5c968380d0cd6068f4638298c"></a><!-- doxytag: member="spi.h::SpiConfigWriteTerminationDelay" ref="ga713744d5c968380d0cd6068f4638298c" args="(uint16 delay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpiConfigWriteTerminationDelay </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>delay</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the Write Termination Delay configuration parameter. </p>
<p>The Write Termination Delay is the minimum period in microseconds that the chip select line will be held active after a write completes. Some devices may require a long period to allow the data to be stored before CS goes inactive.</p>
<p>With no delays specified the SPI driver code has an approximate delay of 8us due to internal processing, although this is not guaranteed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">delay</td><td>Extra delay (in microseconds). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga25460907c92c934ef3d69bf17cf7b55e"></a><!-- doxytag: member="spi_flash.h::SpiFlashEraseBlock" ref="ga25460907c92c934ef3d69bf17cf7b55e" args="(spi_erase_size size, uint16 address, bool wait)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a> SpiFlashEraseBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SPI.html#ga053f5a2994fa79d9817609c75d5049aa">spi_erase_size</a>&#160;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>wait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erase a single block of the SPI Flash memory device. </p>
<p>The block is determined by the address passed in. Typically this will be the first address of the block, although devices may allow any address within the block to be used. The size of the block to be erased is determined by the size parameter. The driver currently supports erasing 4KB or 32KB blocks.</p>
<p>The caller can specify whether or not the driver waits for the erase operation to finish before returning. With typical block erase times of up to a second, this allows the application to continue doing other processing while the erase operation completes. If the driver does not wait, then the caller MUST ensure that the erase has finished by later calling SpiFlashEraseComplete() before performing any other operations with the SPi Flash driver.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size of block to erase </td></tr>
    <tr><td class="paramname">address</td><td>Address corresponding to block to be erased </td></tr>
    <tr><td class="paramname">wait</td><td>TRUE if the driver should wait for the erase to finish</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status of operation </dd></dl>

</div>
</div>
<a class="anchor" id="gaefcd3a272c32c20f8379be625e714249"></a><!-- doxytag: member="spi_flash.h::SpiFlashEraseWaitComplete" ref="gaefcd3a272c32c20f8379be625e714249" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a> SpiFlashEraseWaitComplete </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Waits for an erase operation to complete. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status of operation </dd></dl>

</div>
</div>
<a class="anchor" id="ga7ef899a7e0bb261d7c0bddef1a82327a"></a><!-- doxytag: member="spi_flash.h::SpiFlashInit" ref="ga7ef899a7e0bb261d7c0bddef1a82327a" args="(uint16 ncs_pio, uint16 power_pio)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpiFlashInit </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>ncs_pio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>power_pio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialise the SPI Flash library. </p>
<p>Configure the NVM hardware for communication with a SPI Flash device. The SPI Flash must be on the same SPI bus as the boot flash (it is therefore not possible to use this interface to communicate with a SPI Flash device if the CSR1000 was booted from an I2C EEPROM).</p>
<p>The hardware has a fixed 8MHz SPI clock for all transactions.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ncs_pio</td><td>PIO (0-15) to use for SPI Flash Chip Select (active low). </td></tr>
    <tr><td class="paramname">power_pio</td><td>PIO (0-15) to use for SPI Flash power. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad2501aed56a2e4c3d59c8f6b02c3081e"></a><!-- doxytag: member="spi_flash.h::SpiFlashRead" ref="gad2501aed56a2e4c3d59c8f6b02c3081e" args="(uint16 address, uint16 length, uint16 *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a> SpiFlashRead </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"> <em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read data from the selected SPI Flash device. </p>
<p>The data is read in units of bytes. The application should supply a pointer to a packed array (that is, a uint16*). This is to optimise the amount of RAM required to read data from a SPI Flash device. If an odd number of bytes are requested, the unused byte of the final packed word will be set to 0x00.</p>
<p>Due to fixed internal timeouts, it is recommended that no more than 4KB (4096 bytes) is read in a single transaction.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Address in SPI Flash memory to start reading the data from. </td></tr>
    <tr><td class="paramname">length</td><td>The number of <b>bytes</b> to read. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to storage for the data that is read (packed array)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status of operation </dd></dl>

</div>
</div>
<a class="anchor" id="ga39d8d965b9920e98f68aeebe4b362439"></a><!-- doxytag: member="spi_flash.h::SpiFlashWrite" ref="ga39d8d965b9920e98f68aeebe4b362439" args="(uint16 address, uint16 length, const uint16 *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__STAT.html#ga4d0e4416aa801fbed0a19d3d24fdbba6">sys_status</a> SpiFlashWrite </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16 *&#160;</td>
          <td class="paramname"> <em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write data to the selected SPI Flash device. </p>
<p>The data is written in units of bytes. The application should supply a pointer to a packed array (that is, a uint16*). This is to optimise the amount of RAM required to write data to a SPI Flash device.</p>
<p>The caller must ensure that no more than one full page (often 256 bytes, although dependent on selected device parameters) is written in a single transaction.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Address in SPI Flash memory to start writing the data to </td></tr>
    <tr><td class="paramname">length</td><td>The number of <b>bytes</b> to write </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the data to be written (packed array)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status of operation </dd></dl>

</div>
</div>
<a class="anchor" id="ga161ff18d77ad85f32b915ffbaf02264b"></a><!-- doxytag: member="spi.h::SpiInit" ref="ga161ff18d77ad85f32b915ffbaf02264b" args="(uint16 mosi_pio, uint16 miso_pio, uint16 clk_pio, uint16 ncs_pio)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SpiInit </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>mosi_pio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>miso_pio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>clk_pio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>ncs_pio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialise the SPI library. </p>
<p>Configure the PIOs required for SPI bus communication, with the CSR1xxx operating as SPI Master, using SPI Mode 3. All read and write operations assume 8-bit values. The Most Significant Bit (MSB) will be clocked out (for writes) or clocked in (for reads) first. The protocol is assumed to be half-duplex, i.e. when writing bytes, read data is ignored, and vice-versa.</p>
<p>SPI bus transactions are implemented using a software driver to control the selected PIO lines. Therefore the fundamental SPI clock rate is restricted by the speed of the processor. In practise we have found the clock rate to be approximately 470kHz. The clock rate is fixed.</p>
<p>After calling this function all subsequent Spi*() operations will use the selected PIOs for communicating with the SPI peripheral. If an application wishes to communicate with two independent SPI devices on the same bus it must call <a class="el" href="group__SPI.html#ga161ff18d77ad85f32b915ffbaf02264b" title="Initialise the SPI library.">SpiInit()</a> each time it wishes to switch to the other SPI device. Typically an implementation would have SPI Clock and SPI Data signals assigned to common PIOs while the SPI Chip Select signal for each SPI slave device would have a dedicated PIO. However this arrangement is not mandatory.</p>
<p>Calling this function will clear the delay configuration parameters (Read Register Delay and Write Termination Delay).</p>
<dl class="note"><dt><b>Note:</b></dt><dd>All 4 SPI PIO lines must be in the same bank (0-15 or 16-31)</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mosi_pio</td><td>PIO (0-31) to use for SPI Data Master Out/Slave In. </td></tr>
    <tr><td class="paramname">miso_pio</td><td>PIO (0-31) to use for SPI Data Master In/Slave Out. </td></tr>
    <tr><td class="paramname">clk_pio</td><td>PIO (0-31) to use for SPI Clock. </td></tr>
    <tr><td class="paramname">ncs_pio</td><td>PIO (0-31) to use for SPI Slave Chip Select (active low), or <a class="el" href="group__SPI.html#ga6a72cd674aaf77593f0383220219b1c4">SPI_NCS_PIO_UNDEFINED</a> to control chip select from the application.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if bus is initialised or FALSE if there was an error </dd></dl>

</div>
</div>
<a class="anchor" id="ga2c087dfb5aeb88adc70e0b3669e76f6b"></a><!-- doxytag: member="spi.h::SpiRead" ref="ga2c087dfb5aeb88adc70e0b3669e76f6b" args="(uint8 *in_buffer, uint16 length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 SpiRead </td>
          <td>(</td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"> <em>in_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a sequence of bytes of data from a SPI peripheral device and copy the data into the supplied buffer. </p>
<p>The SPI slave device is selected, the array of bytes is clocked in, and then the device is de-selected.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in_buffer</td><td>Array of bytes to store data read from the SPI device. </td></tr>
    <tr><td class="paramname">length</td><td>Number of bytes to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes read (which will always be <code>'length'</code>). </dd></dl>

</div>
</div>
<a class="anchor" id="ga498d7d3626d0229955ff3dcf1ec5a6c8"></a><!-- doxytag: member="spi.h::SpiReadByte" ref="ga498d7d3626d0229955ff3dcf1ec5a6c8" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8 SpiReadByte </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read one byte of data from a SPI peripheral device. </p>
<p>The SPI slave device is selected, the byte is clocked in, and then the device is de-selected.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The byte value read from the SPI device. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6bbb9774772d33ceb8b1a02412ad5131"></a><!-- doxytag: member="spi.h::SpiReadRegister" ref="ga6bbb9774772d33ceb8b1a02412ad5131" args="(uint8 reg_address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8 SpiReadRegister </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"> <em>reg_address</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read from a register on a SPI peripheral device. </p>
<p>The SPI slave device is selected, the register address is clocked out, then the register value is clocked in, and then the device is de-selected.</p>
<p>There is a delay of about 3.5us between writing the register address and reading the values. Some of this delay is fixed due to the internal processing carried out by the SPI device driver. However, as some devices may require longer delays to prepare the burst response, the application can use the function <a class="el" href="group__SPI.html#ga25558cad981aeb123f8a56de322f1930">SpiConfigReadRegisterDelay()</a> to set an additional delay. During this delay the SPI slave device remains selected.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">reg_address</td><td>The address of the register to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The register value read from the SPI device. </dd></dl>

</div>
</div>
<a class="anchor" id="ga27a763c150d7f8bce817c45d8a7539c9"></a><!-- doxytag: member="spi.h::SpiReadRegisterBurst" ref="ga27a763c150d7f8bce817c45d8a7539c9" args="(uint8 reg_address, uint8 *in_buffer, uint16 length, bool toggle_clk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 SpiReadRegisterBurst </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"> <em>reg_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"> <em>in_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>toggle_clk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Burst read multiple registers on a SPI peripheral device. </p>
<p>The SPI slave device is selected, the register address is clocked out, multiple register values are clocked in, and then the device is de-selected.</p>
<p>This procedure assumes that the SPI slave device will prepare the Burst Read response, such that from the first register address it will return a device-specific series of register values within one SPI transaction, with no further address writes required between values.</p>
<p>There is a delay of about 3.5us between writing the register address and reading the values. Some of this delay is fixed due to the internal processing carried out by the SPI device driver. However, as some devices may require longer delays to prepare the burst response, the application can use the function <a class="el" href="group__SPI.html#ga25558cad981aeb123f8a56de322f1930">SpiConfigReadRegisterDelay()</a> to set an additional delay. During this delay the SPI slave device remains selected.</p>
<p>The parameter <code>'toggle_clk'</code> should normally be left set to FALSE. It is provided for compatibility with certain SPI devices. It adds an extra clock cycle between writing the register address and reading the first register value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">reg_address</td><td>The first register address. </td></tr>
    <tr><td class="paramname">in_buffer</td><td>Array of bytes to store register values read from the SPI device. </td></tr>
    <tr><td class="paramname">length</td><td>Number of bytes to read. </td></tr>
    <tr><td class="paramname">toggle_clk</td><td>Configuration parameter to toggle clock after write</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes read (which will always be <code>'length'</code>). </dd></dl>

</div>
</div>
<a class="anchor" id="ga1141e72a5264210e0999e9b4c11e186d"></a><!-- doxytag: member="spi.h::SpiWrite" ref="ga1141e72a5264210e0999e9b4c11e186d" args="(const uint8 *out_buffer, uint16 length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 SpiWrite </td>
          <td>(</td>
          <td class="paramtype">const uint8 *&#160;</td>
          <td class="paramname"> <em>out_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a sequence of bytes of data to a SPI peripheral device. </p>
<p>The SPI slave device is selected, the array of bytes is clocked out, and then the device is de-selected.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out_buffer</td><td>Array of bytes to write to the SPI device. </td></tr>
    <tr><td class="paramname">length</td><td>Number of bytes in the array to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes written (which will always be <code>'length'</code>). </dd></dl>

</div>
</div>
<a class="anchor" id="ga9c509dc2a5c998a6c3556d1c54ab3f06"></a><!-- doxytag: member="spi.h::SpiWriteByte" ref="ga9c509dc2a5c998a6c3556d1c54ab3f06" args="(uint8 byte)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpiWriteByte </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"> <em>byte</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write one byte of data to a SPI peripheral device. </p>
<p>The SPI slave device is selected, the byte is clocked out, and then the device is de-selected.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">byte</td><td>The byte to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaccc9b929868870a6bd2a498a7f8dbdce"></a><!-- doxytag: member="spi.h::SpiWriteRegister" ref="gaccc9b929868870a6bd2a498a7f8dbdce" args="(uint8 reg_address, uint8 reg_value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpiWriteRegister </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"> <em>reg_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"> <em>reg_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write to a register on a SPI peripheral device. </p>
<p>The SPI slave device is selected, the register address is clocked out, the register value is clocked out, and then the device is de-selected.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">reg_address</td><td>The address of the register to be written. </td></tr>
    <tr><td class="paramname">reg_value</td><td>The value to write to the register. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Jun 22 2016 11:39:14 for CSR ÂµEnergy&reg; Firmware by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
