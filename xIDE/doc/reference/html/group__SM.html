<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CSR ÂµEnergy&reg; Firmware: Security Manager</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Security Manager<br/>
<small>
[<a class="el" href="group__BLE.html">Bluetooth v4.1 (Bluetooth Smart) Protocol Stack</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SM.html#ga7c41a82763af224fe42294174cf4f7d3">SMPasskeyDisplayed</a>(bd_addr)&#160;&#160;&#160;SMPasskeyInput(bd_addr, NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">After receiving <a class="el" href="core__event__types_8h.html#ae083b8895a062f0687dab74b63a897edadc818c18e990f4769f3f8fefba4b7b6a" title="Indicates that the Security Manager is in pairing mode, and need the application to display the pass ...">SM_PASSKEY_DISPLAY_IND</a> this function call confirms that the passkey has been displayed.  <a href="#ga7c41a82763af224fe42294174cf4f7d3"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SM.html#ga058db9a33ec190064dc9c66276fb9a14">sm_io_capabilities</a> { <br/>
&#160;&#160;<a class="el" href="group__SM.html#gga058db9a33ec190064dc9c66276fb9a14a90faa925cc60623c95d3ea6c824659c6">SM_IO_CAP_DISPLAY_ONLY</a> =  0, 
<a class="el" href="group__SM.html#gga058db9a33ec190064dc9c66276fb9a14a44a874c94229ee9661ccccb74fc743e0">SM_IO_CAP_DISPLAY_YES_NO</a>, 
<a class="el" href="group__SM.html#gga058db9a33ec190064dc9c66276fb9a14a658f19b6a090733d51825c304f0c9212">SM_IO_CAP_KEYBOARD_ONLY</a>, 
<a class="el" href="group__SM.html#gga058db9a33ec190064dc9c66276fb9a14a0d74882c465e255f07ff4a6f99a52f05">SM_IO_CAP_NO_INPUT_NO_OUTPUT</a>, 
<br/>
&#160;&#160;<a class="el" href="group__SM.html#gga058db9a33ec190064dc9c66276fb9a14a6ba929836c73d48bf7fda700e47046ef">SM_IO_CAP_KEYBOARD_DISPLAY</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Defines of the I/O capabilities of a device. </p>
 <a href="group__SM.html#ga058db9a33ec190064dc9c66276fb9a14">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SM.html#ga9048bfbae535e0b29dd1d67acd240315">sm_oob_data_present</a> { <b>SM_OOB_DATA_NOT_PRESENT</b> =  0, 
<b>SM_OOB_DATA_PRESENT</b>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Currently unimplemented. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SM.html#ga4626538b0556ca1348aef84c8e7dc925">sm_div_verdict</a> { <a class="el" href="group__SM.html#gga4626538b0556ca1348aef84c8e7dc925ac9625399247d2c1eac8db658d8a499d4">SM_DIV_APPROVED</a> =  0, 
<a class="el" href="group__SM.html#gga4626538b0556ca1348aef84c8e7dc925a62ee424f44e429feb1323c9a98851ae2">SM_DIV_REVOKED</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Response codes for the diversifier verdict. </p>
 <a href="group__SM.html#ga4626538b0556ca1348aef84c8e7dc925">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SM.html#gacc8920a6a7ff928f699d42a3682871b4">sm_key_type</a> { <br/>
&#160;&#160;<a class="el" href="group__SM.html#ggacc8920a6a7ff928f699d42a3682871b4a380c2a317a2b90a9882062b98f5cc002">SM_KEY_TYPE_NONE</a>, 
<a class="el" href="group__SM.html#ggacc8920a6a7ff928f699d42a3682871b4acf9afd9094b952363a1696d1be90a46a">SM_KEY_TYPE_ENC_CENTRAL</a>, 
<a class="el" href="group__SM.html#ggacc8920a6a7ff928f699d42a3682871b4a0e8526338d46109e31244efbb5697113">SM_KEY_TYPE_DIV</a>, 
<a class="el" href="group__SM.html#ggacc8920a6a7ff928f699d42a3682871b4a0e4264ac4386d170449bf9fed9b85e3f">SM_KEY_TYPE_SIGN</a>, 
<br/>
&#160;&#160;<a class="el" href="group__SM.html#ggacc8920a6a7ff928f699d42a3682871b4a680d8eb595963b16eef9e0a16eae0d30">SM_KEY_TYPE_ID</a>, 
<a class="el" href="group__SM.html#ggacc8920a6a7ff928f699d42a3682871b4a9b4aaa96e9bca737ed66a88045bad93e">SM_BD_ADDR</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Defines types of security information present in an <a class="el" href="structSM__KEYSET__T.html" title="Security Information block.">SM_KEYSET_T</a> by the (1&lt;&lt;<a class="el" href="group__SM.html#gacc8920a6a7ff928f699d42a3682871b4" title="Defines types of security information present in an SM_KEYSET_T by the (1&lt;&lt;sm_key_type) bit bei...">sm_key_type</a>) bit being set in SM_KEYSET_T::keys_present. </p>
 <a href="group__SM.html#gacc8920a6a7ff928f699d42a3682871b4">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SM.html#gaa8ff01617ae2f6aaa3aca0a40b24519e">SMEncryptRawAes</a> (uint16 *key, uint16 *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">AES encrypt a block of data.  <a href="#gaa8ff01617ae2f6aaa3aca0a40b24519e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SM.html#gac1f38da6fe0b71854bd80c015ebf4fe1">SMInit</a> (uint16 div)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialising the Security Manager. The application has to supply SMinit() with the latest distributed diversifier, in order to maintain unique keys after a power cycle. This function shall be called after <a class="el" href="group__GCOM.html#ga34206a2bb33dbb80aa14ad8e31223d1b" title="Initialisation function for GATT module.">GattInit()</a>.  <a href="#gac1f38da6fe0b71854bd80c015ebf4fe1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SM.html#ga1ff3ba17cce35e1b35620f7e4c456c98">SMFeaturesReq</a> (bool enable_key_storage, bool enable_keys_request, bool enable_div_approval, bool enable_pairing_auth, bool enable_long_term_key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime configuration of Security Manager features. On-chip applications will never need to call this function, as for those applications SM features are derived at link time. However, some classes of application that communicate with an off-chip host processor may find this function useful.  <a href="#ga1ff3ba17cce35e1b35620f7e4c456c98"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SM.html#ga971b9e7871f9b4c9724d2671314857b2">SMRequestSecurityLevel</a> (<a class="el" href="structTYPED__BD__ADDR__T.html">TYPED_BD_ADDR_T</a> *bd_addr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts security procedures on the link. For a master device this may involve initiating Encryption or Pairing. For a slave device this will send a Security Request to the master.  <a href="#ga971b9e7871f9b4c9724d2671314857b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SM.html#ga4f770974ff2a989e93b4aa0844be7e0b">SMKeyRequestResponse</a> (const <a class="el" href="structTYPED__BD__ADDR__T.html">TYPED_BD_ADDR_T</a> *bd_addr, const <a class="el" href="structSM__KEYSET__T.html">SM_KEYSET_T</a> *keyset)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Supplies a key previously stored by the application.  <a href="#ga4f770974ff2a989e93b4aa0844be7e0b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SM.html#ga14208b1ea5ed21e388b1457cd7985ea3">SMAddStoredKey</a> (const <a class="el" href="structTYPED__BD__ADDR__T.html">TYPED_BD_ADDR_T</a> *bd_addr, const <a class="el" href="structSM__KEYSET__T.html">SM_KEYSET_T</a> *keyset)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a key in the Security Manager persistent storage.  <a href="#ga14208b1ea5ed21e388b1457cd7985ea3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SM.html#gab2d2203ea43efbda30d893d0cd6c9814">SMReadStoredKey</a> (const <a class="el" href="structTYPED__BD__ADDR__T.html">TYPED_BD_ADDR_T</a> *bd_addr, <a class="el" href="structSM__KEYSET__T.html">SM_KEYSET_T</a> *keyset)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a key from the Security Manager persistent storage.  <a href="#gab2d2203ea43efbda30d893d0cd6c9814"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SM.html#ga9af97d85dce66f8e384f35c3e8beaa31">SMRemoveStoredKey</a> (const <a class="el" href="structTYPED__BD__ADDR__T.html">TYPED_BD_ADDR_T</a> *bd_addr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a key from the Security Manager persistent storage.  <a href="#ga9af97d85dce66f8e384f35c3e8beaa31"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SM.html#gad70ff385804942631a0ccbcbd84f66dc">SMSetIOCapabilities</a> (<a class="el" href="group__SM.html#ga058db9a33ec190064dc9c66276fb9a14">sm_io_capabilities</a> io_capabilities)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function set the I/O capabilities of the device.  <a href="#gad70ff385804942631a0ccbcbd84f66dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SM.html#ga0442d24eb07891a1c4839f41dd60d8c8">SMSetMaxEncKeySize</a> (<a class="el" href="group__SM.html#ga0640428f0e6d83ca3aaaa37d52bccf21">sm_enc_key_size</a> key_size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function set the maximum accepted encryption key size.  <a href="#ga0442d24eb07891a1c4839f41dd60d8c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SM.html#gaaba41e633fd06ae878d223e5fe2201a6">SMSetMinEncKeySize</a> (<a class="el" href="group__SM.html#ga0640428f0e6d83ca3aaaa37d52bccf21">sm_enc_key_size</a> key_size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function set the minimum accepted encryption key size.  <a href="#gaaba41e633fd06ae878d223e5fe2201a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SM.html#ga122035cca4027eab03f54a4b7d3aabf3">SMDistributeMasterLtk</a> (bool distribute_ltk)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate whether the Security Manager should request distribution of the master's Long Term Key during bonding.  <a href="#ga122035cca4027eab03f54a4b7d3aabf3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SM.html#ga77237ecef0d81f730454ba939af623bf">SMPrivacyRegenerateAddress</a> (uint24 random)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate and set a new resolvable private address.  <a href="#ga77237ecef0d81f730454ba939af623bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SM.html#ga21a72ccdbdf93b2a3e248f925d4ba8df">SMPrivacyMatchAddress</a> (const <a class="el" href="structTYPED__BD__ADDR__T.html">TYPED_BD_ADDR_T</a> *addr, const uint16 *irk, uint16 num_irk, uint16 size_irk)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to resolve an address against a list of IRKs.  <a href="#ga21a72ccdbdf93b2a3e248f925d4ba8df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafb0b54b7aa6df15dbb7d8c926540ca95"></a><!-- doxytag: member="SM::SMSetOOBDataPresent" ref="gafb0b54b7aa6df15dbb7d8c926540ca95" args="(sm_oob_data_present oob_data_present)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SM.html#gafb0b54b7aa6df15dbb7d8c926540ca95">SMSetOOBDataPresent</a> (<a class="el" href="group__SM.html#ga9048bfbae535e0b29dd1d67acd240315">sm_oob_data_present</a> oob_data_present)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Currently unsupported. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SM.html#gad8e81a03a33d3312c29fd49f0151b7e6">SMPasskeyInput</a> (<a class="el" href="structTYPED__BD__ADDR__T.html">TYPED_BD_ADDR_T</a> *bd_addr, const uint32 *passkey)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">After receiving an <a class="el" href="core__event__types_8h.html#ae083b8895a062f0687dab74b63a897eda98b6d7598c5b09e317ee5cb72e604574" title="Indicates that the Security Manager is in pairing mode, and need the user to enter the pass key displ...">SM_PASSKEY_INPUT_IND</a> this function call indicates to the Security Manager that the user input a passkey.  <a href="#gad8e81a03a33d3312c29fd49f0151b7e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SM.html#gaced506b479992f43b46d2ce2659e25e8">SMPasskeyInputNeg</a> (<a class="el" href="structTYPED__BD__ADDR__T.html">TYPED_BD_ADDR_T</a> *bd_addr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">After receiving an <a class="el" href="core__event__types_8h.html#ae083b8895a062f0687dab74b63a897eda98b6d7598c5b09e317ee5cb72e604574" title="Indicates that the Security Manager is in pairing mode, and need the user to enter the pass key displ...">SM_PASSKEY_INPUT_IND</a> or <a class="el" href="core__event__types_8h.html#ae083b8895a062f0687dab74b63a897edadc818c18e990f4769f3f8fefba4b7b6a" title="Indicates that the Security Manager is in pairing mode, and need the application to display the pass ...">SM_PASSKEY_DISPLAY_IND</a> this function call indicates to the Security Manager that the user cancelled passkey pairing.  <a href="#gaced506b479992f43b46d2ce2659e25e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SM.html#ga2320943f4f152defb56ffe55ebfdca6a">SMDivApproval</a> (uint16 cid, <a class="el" href="group__SM.html#ga4626538b0556ca1348aef84c8e7dc925">sm_div_verdict</a> verdict)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Approve or reject encrypting the link with the LTK referred to by diversifier in the SM_DIV_APPROVAL_IND.  <a href="#ga2320943f4f152defb56ffe55ebfdca6a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SM.html#ga88b13d9d5d65e4d4f76d13373789b4a1">SMPairingAuthRsp</a> (void *data, bool authorised)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Authorise or reject a pairing request from the peer device.  <a href="#ga88b13d9d5d65e4d4f76d13373789b4a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SM.html#gad3f0a6912c88c72871e8975e2fb5f422">SMLongTermKeyRsp</a> (uint16 cid, uint16 *long_term_key, bool mitm_protection, uint8 key_size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the application in response to an SM_LONG_TERM_KEY_IND to provide the firmware with an externally-generated Long Term Key for the current connection (if it has one) or to indicate that it does not have an LTK available for this connection.  <a href="#gad3f0a6912c88c72871e8975e2fb5f422"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SM.html#ga82cc446735cbf5cc535dcc6abe272bbc">SMPrivacyGetOwnIrk</a> (uint16 *irk)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get device's own IRK.  <a href="#ga82cc446735cbf5cc535dcc6abe272bbc"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0640428f0e6d83ca3aaaa37d52bccf21"></a><!-- doxytag: member="SM::sm_enc_key_size" ref="ga0640428f0e6d83ca3aaaa37d52bccf21" args="" -->
typedef uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SM.html#ga0640428f0e6d83ca3aaaa37d52bccf21">sm_enc_key_size</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the size, in octets, of the encryption key. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacbef477407aa1bdf4825d5cfcebb1421"></a><!-- doxytag: member="SM::SM_MAX_ENC_KEY_SIZE" ref="gacbef477407aa1bdf4825d5cfcebb1421" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SM_MAX_ENC_KEY_SIZE</b>&#160;&#160;&#160;((<a class="el" href="group__SM.html#ga0640428f0e6d83ca3aaaa37d52bccf21">sm_enc_key_size</a>)0x10)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga81471b20d6a823be6e3dcc1941ac3cb2"></a><!-- doxytag: member="SM::SM_MIN_ENC_KEY_SIZE" ref="ga81471b20d6a823be6e3dcc1941ac3cb2" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SM_MIN_ENC_KEY_SIZE</b>&#160;&#160;&#160;((<a class="el" href="group__SM.html#ga0640428f0e6d83ca3aaaa37d52bccf21">sm_enc_key_size</a>)0x07)</td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga7c41a82763af224fe42294174cf4f7d3"></a><!-- doxytag: member="security.h::SMPasskeyDisplayed" ref="ga7c41a82763af224fe42294174cf4f7d3" args="(bd_addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SMPasskeyDisplayed</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bd_addr&#160;)</td>
          <td>&#160;&#160;&#160;SMPasskeyInput(bd_addr, NULL)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>After receiving <a class="el" href="core__event__types_8h.html#ae083b8895a062f0687dab74b63a897edadc818c18e990f4769f3f8fefba4b7b6a" title="Indicates that the Security Manager is in pairing mode, and need the application to display the pass ...">SM_PASSKEY_DISPLAY_IND</a> this function call confirms that the passkey has been displayed. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>If the application wishes to display a different passkey from the one suggested in <a class="el" href="core__event__types_8h.html#ae083b8895a062f0687dab74b63a897edadc818c18e990f4769f3f8fefba4b7b6a" title="Indicates that the Security Manager is in pairing mode, and need the application to display the pass ...">SM_PASSKEY_DISPLAY_IND</a> it should call <a class="el" href="group__SM.html#gad8e81a03a33d3312c29fd49f0151b7e6" title="After receiving an SM_PASSKEY_INPUT_IND this function call indicates to the Security Manager that the...">SMPasskeyInput()</a> instead to tell the Security Manager the new passkey. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bd_addr</td><td>from <a class="el" href="core__event__types_8h.html#ae083b8895a062f0687dab74b63a897edadc818c18e990f4769f3f8fefba4b7b6a" title="Indicates that the Security Manager is in pairing mode, and need the application to display the pass ...">SM_PASSKEY_DISPLAY_IND</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None </dd></dl>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga4626538b0556ca1348aef84c8e7dc925"></a><!-- doxytag: member="security.h::sm_div_verdict" ref="ga4626538b0556ca1348aef84c8e7dc925" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__SM.html#ga4626538b0556ca1348aef84c8e7dc925">sm_div_verdict</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Response codes for the diversifier verdict. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga4626538b0556ca1348aef84c8e7dc925ac9625399247d2c1eac8db658d8a499d4"></a><!-- doxytag: member="SM_DIV_APPROVED" ref="gga4626538b0556ca1348aef84c8e7dc925ac9625399247d2c1eac8db658d8a499d4" args="" -->SM_DIV_APPROVED</em>&nbsp;</td><td>
<p>Diversifier and the corresponding LTK valid </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga4626538b0556ca1348aef84c8e7dc925a62ee424f44e429feb1323c9a98851ae2"></a><!-- doxytag: member="SM_DIV_REVOKED" ref="gga4626538b0556ca1348aef84c8e7dc925a62ee424f44e429feb1323c9a98851ae2" args="" -->SM_DIV_REVOKED</em>&nbsp;</td><td>
<p>Diversifier and the corresponding LTK has been revoked </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga058db9a33ec190064dc9c66276fb9a14"></a><!-- doxytag: member="security.h::sm_io_capabilities" ref="ga058db9a33ec190064dc9c66276fb9a14" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__SM.html#ga058db9a33ec190064dc9c66276fb9a14">sm_io_capabilities</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Defines of the I/O capabilities of a device. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga058db9a33ec190064dc9c66276fb9a14a90faa925cc60623c95d3ea6c824659c6"></a><!-- doxytag: member="SM_IO_CAP_DISPLAY_ONLY" ref="gga058db9a33ec190064dc9c66276fb9a14a90faa925cc60623c95d3ea6c824659c6" args="" -->SM_IO_CAP_DISPLAY_ONLY</em>&nbsp;</td><td>
<p>Devices which only have a display </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga058db9a33ec190064dc9c66276fb9a14a44a874c94229ee9661ccccb74fc743e0"></a><!-- doxytag: member="SM_IO_CAP_DISPLAY_YES_NO" ref="gga058db9a33ec190064dc9c66276fb9a14a44a874c94229ee9661ccccb74fc743e0" args="" -->SM_IO_CAP_DISPLAY_YES_NO</em>&nbsp;</td><td>
<p>Devices which have a display plus a yes and no button </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga058db9a33ec190064dc9c66276fb9a14a658f19b6a090733d51825c304f0c9212"></a><!-- doxytag: member="SM_IO_CAP_KEYBOARD_ONLY" ref="gga058db9a33ec190064dc9c66276fb9a14a658f19b6a090733d51825c304f0c9212" args="" -->SM_IO_CAP_KEYBOARD_ONLY</em>&nbsp;</td><td>
<p>Devices which only have a (numeric) keyboard </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga058db9a33ec190064dc9c66276fb9a14a0d74882c465e255f07ff4a6f99a52f05"></a><!-- doxytag: member="SM_IO_CAP_NO_INPUT_NO_OUTPUT" ref="gga058db9a33ec190064dc9c66276fb9a14a0d74882c465e255f07ff4a6f99a52f05" args="" -->SM_IO_CAP_NO_INPUT_NO_OUTPUT</em>&nbsp;</td><td>
<p>Devices which have neither input nor output </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga058db9a33ec190064dc9c66276fb9a14a6ba929836c73d48bf7fda700e47046ef"></a><!-- doxytag: member="SM_IO_CAP_KEYBOARD_DISPLAY" ref="gga058db9a33ec190064dc9c66276fb9a14a6ba929836c73d48bf7fda700e47046ef" args="" -->SM_IO_CAP_KEYBOARD_DISPLAY</em>&nbsp;</td><td>
<p>Devices which have both display and (numeric) keyboard </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gacc8920a6a7ff928f699d42a3682871b4"></a><!-- doxytag: member="security.h::sm_key_type" ref="gacc8920a6a7ff928f699d42a3682871b4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__SM.html#gacc8920a6a7ff928f699d42a3682871b4">sm_key_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Defines types of security information present in an <a class="el" href="structSM__KEYSET__T.html" title="Security Information block.">SM_KEYSET_T</a> by the (1&lt;&lt;<a class="el" href="group__SM.html#gacc8920a6a7ff928f699d42a3682871b4" title="Defines types of security information present in an SM_KEYSET_T by the (1&lt;&lt;sm_key_type) bit bei...">sm_key_type</a>) bit being set in SM_KEYSET_T::keys_present. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggacc8920a6a7ff928f699d42a3682871b4a380c2a317a2b90a9882062b98f5cc002"></a><!-- doxytag: member="SM_KEY_TYPE_NONE" ref="ggacc8920a6a7ff928f699d42a3682871b4a380c2a317a2b90a9882062b98f5cc002" args="" -->SM_KEY_TYPE_NONE</em>&nbsp;</td><td>
<p>Not currently supported </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggacc8920a6a7ff928f699d42a3682871b4acf9afd9094b952363a1696d1be90a46a"></a><!-- doxytag: member="SM_KEY_TYPE_ENC_CENTRAL" ref="ggacc8920a6a7ff928f699d42a3682871b4acf9afd9094b952363a1696d1be90a46a" args="" -->SM_KEY_TYPE_ENC_CENTRAL</em>&nbsp;</td><td>
<p>Peer LTK + EDIV + RAND </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggacc8920a6a7ff928f699d42a3682871b4a0e8526338d46109e31244efbb5697113"></a><!-- doxytag: member="SM_KEY_TYPE_DIV" ref="ggacc8920a6a7ff928f699d42a3682871b4a0e8526338d46109e31244efbb5697113" args="" -->SM_KEY_TYPE_DIV</em>&nbsp;</td><td>
<p>Local DIV sent to peer </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggacc8920a6a7ff928f699d42a3682871b4a0e4264ac4386d170449bf9fed9b85e3f"></a><!-- doxytag: member="SM_KEY_TYPE_SIGN" ref="ggacc8920a6a7ff928f699d42a3682871b4a0e4264ac4386d170449bf9fed9b85e3f" args="" -->SM_KEY_TYPE_SIGN</em>&nbsp;</td><td>
<p>Reserved </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggacc8920a6a7ff928f699d42a3682871b4a680d8eb595963b16eef9e0a16eae0d30"></a><!-- doxytag: member="SM_KEY_TYPE_ID" ref="ggacc8920a6a7ff928f699d42a3682871b4a680d8eb595963b16eef9e0a16eae0d30" args="" -->SM_KEY_TYPE_ID</em>&nbsp;</td><td>
<p>Peer IRK </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggacc8920a6a7ff928f699d42a3682871b4a9b4aaa96e9bca737ed66a88045bad93e"></a><!-- doxytag: member="SM_BD_ADDR" ref="ggacc8920a6a7ff928f699d42a3682871b4a9b4aaa96e9bca737ed66a88045bad93e" args="" -->SM_BD_ADDR</em>&nbsp;</td><td>
<p>Peer public/static BD_ADDR </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga14208b1ea5ed21e388b1457cd7985ea3"></a><!-- doxytag: member="security.h::SMAddStoredKey" ref="ga14208b1ea5ed21e388b1457cd7985ea3" args="(const TYPED_BD_ADDR_T *bd_addr, const SM_KEYSET_T *keyset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SMAddStoredKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTYPED__BD__ADDR__T.html">TYPED_BD_ADDR_T</a> *&#160;</td>
          <td class="paramname"> <em>bd_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSM__KEYSET__T.html">SM_KEYSET_T</a> *&#160;</td>
          <td class="paramname"> <em>keyset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stores a key in the Security Manager persistent storage. </p>
<p>This may be called by the application in response to an SM_KEYS_IND or at any other time the application wishes to store a key in the Security Manager persistent storage</p>
<p>Where this call causes another key to be removed from the persistent store, it will be reported back to the application as per <a class="el" href="group__SM.html#ga9af97d85dce66f8e384f35c3e8beaa31" title="Remove a key from the Security Manager persistent storage.">SMRemoveStoredKey()</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bd_addr</td><td>peer address used as an index for this data </td></tr>
    <tr><td class="paramname">keyset</td><td>Pointer to security keys</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if keys not already stored, otherwise FALSE </dd></dl>

</div>
</div>
<a class="anchor" id="ga122035cca4027eab03f54a4b7d3aabf3"></a><!-- doxytag: member="security.h::SMDistributeMasterLtk" ref="ga122035cca4027eab03f54a4b7d3aabf3" args="(bool distribute_ltk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SMDistributeMasterLtk </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>distribute_ltk</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicate whether the Security Manager should request distribution of the master's Long Term Key during bonding. </p>
<p>During bonding, the peer devices negotiate which keys to distribute to each other. This function allows the application to decide whether the LTK, EDIV and Rand should be distributed by the master of the connection. It can be used when the local device is the master or when it is the slave.</p>
<p>The default is for the Security Manager to not request distribution of the master key, as typically this key is only required if the master and slave devices are likely to swap roles but wish to retain the existing bond.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">distribute_ltk</td><td>Boolean flag indicating whether or not to distribute the master's LTK, EDIV, and Rand. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2320943f4f152defb56ffe55ebfdca6a"></a><!-- doxytag: member="security.h::SMDivApproval" ref="ga2320943f4f152defb56ffe55ebfdca6a" args="(uint16 cid, sm_div_verdict verdict)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SMDivApproval </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>cid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SM.html#ga4626538b0556ca1348aef84c8e7dc925">sm_div_verdict</a>&#160;</td>
          <td class="paramname"> <em>verdict</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Approve or reject encrypting the link with the LTK referred to by diversifier in the SM_DIV_APPROVAL_IND. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Should only be called in response to SM_DIV_APPROVAL_IND, and needs to be called immediately after receiving that event.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cid</td><td>Connection identifier for established BLE-U connection </td></tr>
    <tr><td class="paramname">verdict</td><td>Set to <a class="el" href="group__SM.html#gga4626538b0556ca1348aef84c8e7dc925ac9625399247d2c1eac8db658d8a499d4">SM_DIV_APPROVED</a> if the diversifier refers to an LTK which are valid for encrypting the link. Set to <a class="el" href="group__SM.html#gga4626538b0556ca1348aef84c8e7dc925a62ee424f44e429feb1323c9a98851ae2">SM_DIV_REVOKED</a>, if the diversifier referencing to a revoked LTK.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gaa8ff01617ae2f6aaa3aca0a40b24519e"></a><!-- doxytag: member="crypt.h::SMEncryptRawAes" ref="gaa8ff01617ae2f6aaa3aca0a40b24519e" args="(uint16 *key, uint16 *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SMEncryptRawAes </td>
          <td>(</td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"> <em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>AES encrypt a block of data. </p>
<p>Performs an in-place encryption of supplied plain-text data. The mode of operation is Electronic Code Book, and only one block is encrypted at a time. Data and key should be stored as word-wise little-endian. Example:</p>
<p>The key 0x000102030405060708090a0b0c0d0e0f (MSB -&gt; LSB) is stored</p>
<p>uint16 key[] = {0x0e0f, 0x0c0d, 0x0a0b, 0x0809, 0x0607, 0x0405, 0x0203, 0x0001};</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">key</td><td>pointer to 8 word (128 bit) encryption key </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>pointer to 8 word (128 bit) data block to be encrypted </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>pointer to 8 word (128 bit) encrypted output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1ff3ba17cce35e1b35620f7e4c456c98"></a><!-- doxytag: member="security.h::SMFeaturesReq" ref="ga1ff3ba17cce35e1b35620f7e4c456c98" args="(bool enable_key_storage, bool enable_keys_request, bool enable_div_approval, bool enable_pairing_auth, bool enable_long_term_key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SMFeaturesReq </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>enable_key_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>enable_keys_request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>enable_div_approval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>enable_pairing_auth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>enable_long_term_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Runtime configuration of Security Manager features. On-chip applications will never need to call this function, as for those applications SM features are derived at link time. However, some classes of application that communicate with an off-chip host processor may find this function useful. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>If both enable_key_storage and enable_keys_request are TRUE, then the internal persistent memory will be checked for valid keys. If no keys exist then the application will be asked to supply the keys if it knows about them.</dd></dl>
<p>This function cannot be called before <a class="el" href="group__GCOM.html#ga34206a2bb33dbb80aa14ad8e31223d1b" title="Initialisation function for GATT module.">GattInit()</a> has been called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">enable_key_storage</td><td>If TRUE then the SM will uses its internal persistent memory block for key storage.</td></tr>
    <tr><td class="paramname">enable_keys_request</td><td>If TRUE then the SM will request security keys from the application if it.</td></tr>
    <tr><td class="paramname">enable_div_approval</td><td>If TRUE then the SM will request DIV approval from the application before re-establishing a secure connection.</td></tr>
    <tr><td class="paramname">enable_pairing_auth</td><td>If TRUE then the SM will request pairing authorisation from the application before allowing the peer to start pairing.</td></tr>
    <tr><td class="paramname">enable_long_term_key</td><td>If TRUE then the SM will request an LTK from the application, otherwise it will recreate internally. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac1f38da6fe0b71854bd80c015ebf4fe1"></a><!-- doxytag: member="security.h::SMInit" ref="gac1f38da6fe0b71854bd80c015ebf4fe1" args="(uint16 div)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SMInit </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>div</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialising the Security Manager. The application has to supply SMinit() with the latest distributed diversifier, in order to maintain unique keys after a power cycle. This function shall be called after <a class="el" href="group__GCOM.html#ga34206a2bb33dbb80aa14ad8e31223d1b" title="Initialisation function for GATT module.">GattInit()</a>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>If the application does not intend to revoke keys and does not consider key uniqueness important, this call can be left out.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">div</td><td>latest distributed diversifier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4f770974ff2a989e93b4aa0844be7e0b"></a><!-- doxytag: member="security.h::SMKeyRequestResponse" ref="ga4f770974ff2a989e93b4aa0844be7e0b" args="(const TYPED_BD_ADDR_T *bd_addr, const SM_KEYSET_T *keyset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SMKeyRequestResponse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTYPED__BD__ADDR__T.html">TYPED_BD_ADDR_T</a> *&#160;</td>
          <td class="paramname"> <em>bd_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSM__KEYSET__T.html">SM_KEYSET_T</a> *&#160;</td>
          <td class="paramname"> <em>keyset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Supplies a key previously stored by the application. </p>
<p>Should only be called in response to <a class="el" href="core__event__types_8h.html#ae083b8895a062f0687dab74b63a897edad58ec766767ac3742cc397ad282ad620" title="Indicates that the Security Manager cannot find security keys for the host in its persistent store...">SM_KEY_REQUEST_IND</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bd_addr</td><td>from <a class="el" href="core__event__types_8h.html#ae083b8895a062f0687dab74b63a897edad58ec766767ac3742cc397ad282ad620" title="Indicates that the Security Manager cannot find security keys for the host in its persistent store...">SM_KEY_REQUEST_IND</a> </td></tr>
    <tr><td class="paramname">keyset</td><td>Pointer to security keys or NULL if none available</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="gad3f0a6912c88c72871e8975e2fb5f422"></a><!-- doxytag: member="security.h::SMLongTermKeyRsp" ref="gad3f0a6912c88c72871e8975e2fb5f422" args="(uint16 cid, uint16 *long_term_key, bool mitm_protection, uint8 key_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SMLongTermKeyRsp </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>cid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"> <em>long_term_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>mitm_protection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"> <em>key_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called by the application in response to an SM_LONG_TERM_KEY_IND to provide the firmware with an externally-generated Long Term Key for the current connection (if it has one) or to indicate that it does not have an LTK available for this connection. </p>
<p>The application can use the EDIV and RAND parameters from the master for anything it likes. However they are not required, and can be set to zero at the master side, and ignored at the slave.</p>
<p>If the application has an LTK, it should provide a pointer to key. The 128-bit key 0x000102030405060708090a0b0c0d0e0f (MSB -&gt; LSB) is stored: </p>
<div class="fragment"><pre class="fragment">          uint16 key[] = {0x0e0f, 0x0c0d, 0x0a0b, 0x0809, 0x0607, 0x0405, 0x0203, 0x0001};
</pre></div><p>The application can indicate it does not have a key by setting <em>long_term_key</em> to NULL, or by setting <em>key_size</em> to 0. In this case the Security Manager will recreate the LTK internally using the EDIV and RAND. This may result in a subsequent SM_DIV_APPROVAL_IND message for the application to respond to.</p>
<p>The application should indicate the desired key size. For a 128-bit key, the key size should be set to 16. For shorter keys (for example to meet government export restrictions), the key size can be reduced to any length down to 7 bytes. In this case the firmware will zero the trailing bytes of the key. For example, if the application supplies key 0x123456789abcdef0123456789abcdef0 and states it wants a key size of 8, the firmware will shorten the key to 0x123456789abcdef00000000000000000.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function should only be called in response to <a class="el" href="core__event__types_8h.html#ae083b8895a062f0687dab74b63a897edad47840aec452398a43c4259ff89e67e9" title="Indicates that the Security Manager has received a encryption request from the peer. The application has indicated that it wants to manage some Long Term Keys independently of Security Manager pairing. If the application has an LTK for the current connection then it should call SMLongTermKeyRsp() and provide the key. If it does not have an LTK it should call SMLongTermKeyRsp() with appropriate status to pass handling of encryption back to the Security Manager (in which case SM will recreate the LTK using the EDIV and RAND, and optionally may then ask the application for DIV approval).">SM_LONG_TERM_KEY_IND</a>, and shall be called immediately after receiving that event.</dd>
<dd>
Unlike internally-generated LTKs, the firmware does not compare the current security mode (unauthenticated or authenticated) against the MITM protection flag for the supplied key.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cid</td><td>Connection identifier for established BLE-U connection </td></tr>
    <tr><td class="paramname">long_term_key</td><td>Pointer to an LTK for this connection, or NULL if the application does not have an LTK for the link. The LTK is an 8-word array. </td></tr>
    <tr><td class="paramname">mitm_protection</td><td>TRUE if the LTK includes Man-in-the-Middle protection. If the LTK was randomly-generated then this should be TRUE. </td></tr>
    <tr><td class="paramname">key_size</td><td>Encryption key size (7 to 16 bytes) of the LTK</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing </dd></dl>

</div>
</div>
<a class="anchor" id="ga88b13d9d5d65e4d4f76d13373789b4a1"></a><!-- doxytag: member="security.h::SMPairingAuthRsp" ref="ga88b13d9d5d65e4d4f76d13373789b4a1" args="(void *data, bool authorised)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SMPairingAuthRsp </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>authorised</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Authorise or reject a pairing request from the peer device. </p>
<p>If the application does not call (or reference) this function, then all pairing requests will be handled automatically by the firmware. * The 'data' parameter should be copied from the SM_PAIRING_AUTH_IND event sent to the application.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Should only be called in response to SM_PAIRIING_AUTH_IND, and needs to be called immediately after receiving that event.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data parameter from the original IND event </td></tr>
    <tr><td class="paramname">authorised</td><td>Boolean flag: TRUE indicates the pairing may proceed. FALSE rejects the pairing request.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gad8e81a03a33d3312c29fd49f0151b7e6"></a><!-- doxytag: member="security.h::SMPasskeyInput" ref="gad8e81a03a33d3312c29fd49f0151b7e6" args="(TYPED_BD_ADDR_T *bd_addr, const uint32 *passkey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SMPasskeyInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTYPED__BD__ADDR__T.html">TYPED_BD_ADDR_T</a> *&#160;</td>
          <td class="paramname"> <em>bd_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *&#160;</td>
          <td class="paramname"> <em>passkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>After receiving an <a class="el" href="core__event__types_8h.html#ae083b8895a062f0687dab74b63a897eda98b6d7598c5b09e317ee5cb72e604574" title="Indicates that the Security Manager is in pairing mode, and need the user to enter the pass key displ...">SM_PASSKEY_INPUT_IND</a> this function call indicates to the Security Manager that the user input a passkey. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bd_addr</td><td>from <a class="el" href="core__event__types_8h.html#ae083b8895a062f0687dab74b63a897eda98b6d7598c5b09e317ee5cb72e604574" title="Indicates that the Security Manager is in pairing mode, and need the user to enter the pass key displ...">SM_PASSKEY_INPUT_IND</a> </td></tr>
    <tr><td class="paramname">passkey</td><td>pointer to passkey value input </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gaced506b479992f43b46d2ce2659e25e8"></a><!-- doxytag: member="security.h::SMPasskeyInputNeg" ref="gaced506b479992f43b46d2ce2659e25e8" args="(TYPED_BD_ADDR_T *bd_addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SMPasskeyInputNeg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTYPED__BD__ADDR__T.html">TYPED_BD_ADDR_T</a> *&#160;</td>
          <td class="paramname"> <em>bd_addr</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>After receiving an <a class="el" href="core__event__types_8h.html#ae083b8895a062f0687dab74b63a897eda98b6d7598c5b09e317ee5cb72e604574" title="Indicates that the Security Manager is in pairing mode, and need the user to enter the pass key displ...">SM_PASSKEY_INPUT_IND</a> or <a class="el" href="core__event__types_8h.html#ae083b8895a062f0687dab74b63a897edadc818c18e990f4769f3f8fefba4b7b6a" title="Indicates that the Security Manager is in pairing mode, and need the application to display the pass ...">SM_PASSKEY_DISPLAY_IND</a> this function call indicates to the Security Manager that the user cancelled passkey pairing. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bd_addr</td><td>from <a class="el" href="core__event__types_8h.html#ae083b8895a062f0687dab74b63a897eda98b6d7598c5b09e317ee5cb72e604574" title="Indicates that the Security Manager is in pairing mode, and need the user to enter the pass key displ...">SM_PASSKEY_INPUT_IND</a> or <a class="el" href="core__event__types_8h.html#ae083b8895a062f0687dab74b63a897edadc818c18e990f4769f3f8fefba4b7b6a" title="Indicates that the Security Manager is in pairing mode, and need the application to display the pass ...">SM_PASSKEY_DISPLAY_IND</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga82cc446735cbf5cc535dcc6abe272bbc"></a><!-- doxytag: member="security.h::SMPrivacyGetOwnIrk" ref="ga82cc446735cbf5cc535dcc6abe272bbc" args="(uint16 *irk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SMPrivacyGetOwnIrk </td>
          <td>(</td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"> <em>irk</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get device's own IRK. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">irk</td><td>The IRK is 128-bits and consists of 8 consecutive uint16 values, which are stored word wise little endian. This memory should be allocated by the caller. For example: </p>
<div class="fragment"><pre class="fragment">                 uint16 irk[8];
</pre></div></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga21a72ccdbdf93b2a3e248f925d4ba8df"></a><!-- doxytag: member="security.h::SMPrivacyMatchAddress" ref="ga21a72ccdbdf93b2a3e248f925d4ba8df" args="(const TYPED_BD_ADDR_T *addr, const uint16 *irk, uint16 num_irk, uint16 size_irk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SMPrivacyMatchAddress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTYPED__BD__ADDR__T.html">TYPED_BD_ADDR_T</a> *&#160;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16 *&#160;</td>
          <td class="paramname"> <em>irk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>num_irk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"> <em>size_irk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempt to resolve an address against a list of IRKs. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>address to resolve </td></tr>
    <tr><td class="paramname">irk</td><td>pointer to first entry in list of IRKs. Each IRK is 128-bits and so consists of 8 consecutive uint16 values, which are stored word wise little endian.</td></tr>
    <tr><td class="paramname">num_irk</td><td>number of IRKs supplied - suggested default 1 </td></tr>
    <tr><td class="paramname">size_irk</td><td>size in words of each IRK record - suggested default 8, though if the list is actually an array of a larger structure it should be the sizeof array element </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>zero-based index of the first IRK record that is consistent with addr or negative if none are </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>that this function returns immediately with a negative return code if the type of <em>addr</em> is not private resolvable.</dd></dl>
<dl class="user"><dt><b>Example of key:</b></dt><dd>The irk 0x000102030405060708090a0b0c0d0e0f (MSB -&gt; LSB) is stored: <div class="fragment"><pre class="fragment">         uint16 irk[] = {0x0e0f, 0x0c0d, 0x0a0b, 0x0809, 0x0607, 0x0405, 0x0203, 0x0001};
</pre></div></dd></dl>
<dl class="user"><dt><b>Example simple usage:</b></dt><dd><div class="fragment"><pre class="fragment">         uint16 bonded_irk[8];

         <span class="keywordtype">bool</span> IsBondedPeer(<span class="keyword">const</span> <a class="code" href="structTYPED__BD__ADDR__T.html" title="Typed Bluetooth Address type for LE.">TYPED_BD_ADDR_T</a>* addr)
         {
             <span class="keywordflow">return</span> (<a class="code" href="group__SM.html#ga21a72ccdbdf93b2a3e248f925d4ba8df" title="Attempt to resolve an address against a list of IRKs.">SMPrivacyMatchAddress</a>(addr, bonded_irk, 1, 8) == 0);
         }
</pre></div></dd></dl>
<dl class="user"><dt><b>Example advanced usage:</b></dt><dd><div class="fragment"><pre class="fragment">         <span class="keyword">struct</span>
         {
             MyData data;
             <a class="code" href="structSM__KEYSET__T.html" title="Security Information block.">SM_KEYSET_T</a> keys;
         } peer_data[MAX_PEERS];

         <span class="keyword">const</span> <a class="code" href="structTYPED__BD__ADDR__T.html" title="Typed Bluetooth Address type for LE.">TYPED_BD_ADDR_T</a>* PeerResolve(<span class="keyword">const</span> <a class="code" href="structTYPED__BD__ADDR__T.html" title="Typed Bluetooth Address type for LE.">TYPED_BD_ADDR_T</a>* addr)
         {
             <span class="keywordtype">int</span> known_peer = <a class="code" href="group__SM.html#ga21a72ccdbdf93b2a3e248f925d4ba8df" title="Attempt to resolve an address against a list of IRKs.">SMPrivacyMatchAddress</a>(addr, peer_data[0].keys.irk, MAX_PEERS, <span class="keyword">sizeof</span>(*peer_data));
             <span class="keywordflow">if</span> (known_peer &lt; 0)
                 <span class="keywordflow">return</span> addr;
             <span class="keywordflow">return</span> &amp;peer_data[known_peer].keys.id_addr;
         }
</pre></div> </dd></dl>

</div>
</div>
<a class="anchor" id="ga77237ecef0d81f730454ba939af623bf"></a><!-- doxytag: member="security.h::SMPrivacyRegenerateAddress" ref="ga77237ecef0d81f730454ba939af623bf" args="(uint24 random)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SMPrivacyRegenerateAddress </td>
          <td>(</td>
          <td class="paramtype">uint24&#160;</td>
          <td class="paramname"> <em>random</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate and set a new resolvable private address. </p>
<p>This function may be called at any time to change the current random address to a new resolvable private address. It can be called from master and/or slave configuration.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">random</td><td>random part of address or if zero an internal random number generator is used </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FALSE on failure or if random &gt;= 0x3FFFFF </dd></dl>

</div>
</div>
<a class="anchor" id="gab2d2203ea43efbda30d893d0cd6c9814"></a><!-- doxytag: member="security.h::SMReadStoredKey" ref="gab2d2203ea43efbda30d893d0cd6c9814" args="(const TYPED_BD_ADDR_T *bd_addr, SM_KEYSET_T *keyset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SMReadStoredKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTYPED__BD__ADDR__T.html">TYPED_BD_ADDR_T</a> *&#160;</td>
          <td class="paramname"> <em>bd_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSM__KEYSET__T.html">SM_KEYSET_T</a> *&#160;</td>
          <td class="paramname"> <em>keyset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a key from the Security Manager persistent storage. </p>
<p>This may be called with keyset pointer NULL if a simple true/false return code is required.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bd_addr</td><td>index address used in <a class="el" href="group__SM.html#ga14208b1ea5ed21e388b1457cd7985ea3" title="Stores a key in the Security Manager persistent storage.">SMAddStoredKey()</a> </td></tr>
    <tr><td class="paramname">keyset</td><td>Pointer to security key buffer or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if key available, otherwise FALSE </dd></dl>

</div>
</div>
<a class="anchor" id="ga9af97d85dce66f8e384f35c3e8beaa31"></a><!-- doxytag: member="security.h::SMRemoveStoredKey" ref="ga9af97d85dce66f8e384f35c3e8beaa31" args="(const TYPED_BD_ADDR_T *bd_addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SMRemoveStoredKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTYPED__BD__ADDR__T.html">TYPED_BD_ADDR_T</a> *&#160;</td>
          <td class="paramname"> <em>bd_addr</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a key from the Security Manager persistent storage. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bd_addr</td><td>index address used in <a class="el" href="group__SM.html#ga14208b1ea5ed21e388b1457cd7985ea3" title="Stores a key in the Security Manager persistent storage.">SMAddStoredKey()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if address found in key store, otherwise FALSE </dd></dl>

</div>
</div>
<a class="anchor" id="ga971b9e7871f9b4c9724d2671314857b2"></a><!-- doxytag: member="security.h::SMRequestSecurityLevel" ref="ga971b9e7871f9b4c9724d2671314857b2" args="(TYPED_BD_ADDR_T *bd_addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SMRequestSecurityLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTYPED__BD__ADDR__T.html">TYPED_BD_ADDR_T</a> *&#160;</td>
          <td class="paramname"> <em>bd_addr</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts security procedures on the link. For a master device this may involve initiating Encryption or Pairing. For a slave device this will send a Security Request to the master. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bd_addr</td><td>peer address</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FALSE if GAP security mode is NONE or the device is not connected to bd_addr. </dd></dl>

</div>
</div>
<a class="anchor" id="gad70ff385804942631a0ccbcbd84f66dc"></a><!-- doxytag: member="security.h::SMSetIOCapabilities" ref="gad70ff385804942631a0ccbcbd84f66dc" args="(sm_io_capabilities io_capabilities)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SMSetIOCapabilities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SM.html#ga058db9a33ec190064dc9c66276fb9a14">sm_io_capabilities</a>&#160;</td>
          <td class="paramname"> <em>io_capabilities</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function set the I/O capabilities of the device. </p>
<p>When initialising the security manager as well as when no security request are activate is possible to set the I/O capabilities of the device.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">io_capabilities</td><td>I/O capabilities of the device: <a class="el" href="group__SM.html#gga058db9a33ec190064dc9c66276fb9a14a0d74882c465e255f07ff4a6f99a52f05">SM_IO_CAP_NO_INPUT_NO_OUTPUT</a>, <a class="el" href="group__SM.html#gga058db9a33ec190064dc9c66276fb9a14a90faa925cc60623c95d3ea6c824659c6">SM_IO_CAP_DISPLAY_ONLY</a>, <a class="el" href="group__SM.html#gga058db9a33ec190064dc9c66276fb9a14a44a874c94229ee9661ccccb74fc743e0">SM_IO_CAP_DISPLAY_YES_NO</a>, <a class="el" href="group__SM.html#gga058db9a33ec190064dc9c66276fb9a14a658f19b6a090733d51825c304f0c9212">SM_IO_CAP_KEYBOARD_ONLY</a>, <a class="el" href="group__SM.html#gga058db9a33ec190064dc9c66276fb9a14a6ba929836c73d48bf7fda700e47046ef">SM_IO_CAP_KEYBOARD_DISPLAY</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0442d24eb07891a1c4839f41dd60d8c8"></a><!-- doxytag: member="security.h::SMSetMaxEncKeySize" ref="ga0442d24eb07891a1c4839f41dd60d8c8" args="(sm_enc_key_size key_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SMSetMaxEncKeySize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SM.html#ga0640428f0e6d83ca3aaaa37d52bccf21">sm_enc_key_size</a>&#160;</td>
          <td class="paramname"> <em>key_size</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function set the maximum accepted encryption key size. </p>
<p>When initialising the security manager as well as when no security request are activate is possible to set the maximum encryption key size. The key size will be negotiated with the peer and the smaller value of the maximum encryption key length will be used as key size. If this value is small than one of the set minimum encryption key size the paring will fail. Security Manager section 2.3.4</p>
<p>The maximum key size currently support in Low Energy Bluetooth is 16 octet corresponding to a 128 bit key.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Changing the key size while already encrypted will not change the keys before a key refresh request are send.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key_size</td><td>The maximum key size in octets or zero to set default </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaaba41e633fd06ae878d223e5fe2201a6"></a><!-- doxytag: member="security.h::SMSetMinEncKeySize" ref="gaaba41e633fd06ae878d223e5fe2201a6" args="(sm_enc_key_size key_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SMSetMinEncKeySize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SM.html#ga0640428f0e6d83ca3aaaa37d52bccf21">sm_enc_key_size</a>&#160;</td>
          <td class="paramname"> <em>key_size</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function set the minimum accepted encryption key size. </p>
<p>When initialising the security manager as well as when no security request are activate is possible to set the mimimum encryption key size. The key size will be negotiated with the peer and the smaller value of the maximum encryption key size will be used as key size. If this value is smaller than the set minimum encryption key size the paring will fail. Security Manager section 2.3.4</p>
<p>The minimum key size currently support in Low Energy Bluetooth is 7 octet corresponding to a 56 bit key.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Changing the key size while already encrypted will not change the keys before a key refresh request are send.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key_size</td><td>The minimum key size in octets to zero to set default </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Jun 22 2016 11:39:14 for CSR ÂµEnergy&reg; Firmware by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
